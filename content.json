[{"title":"","date":"2022-09-17T16:00:00.000Z","path":"2022/09/18/index/","text":"","updated":"2018-03-06T15:25:52.000Z","categories":[],"tags":[]},{"title":"141. Linked List Cycle","date":"2018-10-04T15:23:46.000Z","path":"2018/10/04/141. Linked List Cycle/","text":"Question:Given a linked list, determine if it has a cycle in it. idea： Use two pointers, walker and runner. walker moves step by step. runner moves two steps at time. if the Linked List has a cycle walker and runner will meet at somepoint.12345678910111213public boolean hasCycle(ListNode head) &#123; if(head==null) return false; ListNode walker = head; ListNode runner = head; while(runner.next!=null &amp;&amp; runner.next.next!=null)&#123; walker = walker.next; runner = runner.next.next; if(walker==runner)&#123; return true; &#125; &#125; return false;&#125;","updated":"2018-10-04T15:27:23.000Z","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"389. Find the Difference","date":"2018-10-04T13:23:36.000Z","path":"2018/10/04/389. Find the Difference/","text":"一般思路:12345678910111213public static char findTheDifference(String s, String t) &#123; int[] map = new int[26]; char c = 97; for(int i=0;i&lt;s.length();i++)&#123; map[s.charAt(i)-&apos;a&apos;]++; &#125; for(int j=0;j&lt;t.length();j++)&#123; map[t.charAt(j)-&apos;a&apos;]--; if(map[t.charAt(j)-&apos;a&apos;]==-1) return t.charAt(j); &#125; return c;&#125; 利用位异或:123456789public static char findTheDifference(String s, String t) &#123; int len = s.length(); char c = t.charAt(len); for (int i = 0; i &lt; len; i++) &#123; c ^= s.charAt(i); c ^= t.charAt(i); &#125; return c; &#125;","updated":"2018-10-04T13:26:20.000Z","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"438. Find All Anagrams in a String","date":"2018-10-04T13:21:28.000Z","path":"2018/10/04/438. Find All Anagrams in a String/","text":"滑动窗口法:123456789101112131415161718192021222324252627282930313233343536public static List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if (s.length() == 0 || p.length() == 0 || s.length() &lt; p.length()) &#123; return res; &#125; int[] chars = new int[26]; for (int i = 0; i &lt; p.length(); i++) &#123; chars[p.charAt(i) - &apos;a&apos;]++; &#125; int start = 0, end = 0, len = p.length(), diff = len; while (end&lt;len)&#123; chars[s.charAt(end)-&apos;a&apos;]--; if(chars[s.charAt(end)-&apos;a&apos;]&gt;=0)&#123; diff--; &#125; end++; &#125; if(diff==0) res.add(0); while(end&lt;s.length())&#123; if(chars[s.charAt(start)-&apos;a&apos;]&gt;=0)&#123; diff++; &#125; chars[s.charAt(start)-&apos;a&apos;]++; start++; chars[s.charAt(end)-&apos;a&apos;]--; if(chars[s.charAt(end)-&apos;a&apos;]&gt;=0)&#123; diff--; &#125; if(diff==0) res.add(start); end++; &#125; return res; &#125;","updated":"2018-10-04T13:21:31.000Z","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Java集合嵌套","date":"2018-03-05T16:00:00.000Z","path":"2018/03/06/Java集合嵌套/","text":"遇到这样返回值12345public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; &#125;&#125; 由于List是接口，不可直接实例化，也就是直接使用List&lt;List&lt;Integer&gt;&gt; list = new List&lt;List&lt;Integer&gt;&gt;();是错的 但如果使用List&lt;List&lt;Integer&gt;&gt; list = new LinkedList&lt;LinkedList&lt;Integer&gt;&gt;();又会报错（cannot convert from LinkedList","updated":"2018-03-06T14:59:24.000Z","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"集合嵌套","slug":"集合嵌套","permalink":"http://yoursite.com/tags/集合嵌套/"}]},{"title":"107. Binary Tree Level Order Traversal II","date":"2018-03-05T16:00:00.000Z","path":"2018/03/06/107. Binary Tree Level Order Traversal II/","text":"题目描述：123456789101112131415Given a binary tree, return the bottom-up level order traversal of its nodes&apos; values. (ie, from left to right, level by level from leaf to root).For example:Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7return its bottom-up level order traversal as:[ [15,7], [9,20], [3]] 思路：使用队列逐层遍历，存到res，不过这道题是反向存储，所以每层得到的List就存入res的起始位置，这样就倒序了这里有两种集合可以实现插入起始位置：若使用ArrayList，使用add(index,ArrayList)方法若使用LinkedList，使用addFirst(ArrayList)方法 PS:这里遇到的一个问题就是返回值是List&lt;List&lt;Integer&gt;&gt;这样的集合嵌套形式，参见我的另一篇Java集合嵌套的笔记。 题解：12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; ArrayList&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(root==null) return res; LinkedList&lt;TreeNode&gt; queue=new LinkedList&lt;TreeNode&gt;(); queue.add(root); int count=1; ArrayList&lt;Integer&gt; middleList=new ArrayList&lt;Integer&gt;(); TreeNode tmp=null; while(!queue.isEmpty())&#123; tmp=queue.poll(); count--; middleList.add(tmp.val); if(tmp.left!=null)&#123; queue.add(tmp.left); //count++; &#125; if(tmp.right!=null)&#123; queue.add(tmp.right); //count++; &#125; if(count==0)&#123; res.add(0,middleList); //insert one by one from the beginning middleList=new ArrayList&lt;Integer&gt;(); //这里注意不能赋值为null count=queue.size(); &#125; &#125; return res; &#125;&#125;","updated":"2018-10-04T13:17:13.000Z","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"集合嵌套","slug":"集合嵌套","permalink":"http://yoursite.com/tags/集合嵌套/"}]},{"title":"airflow前端到后台调用逻辑分析","date":"2017-06-27T16:00:00.000Z","path":"2017/06/28/airflow前端到后台调用逻辑分析/","text":"传参方式分析：使用docker镜像：puckel/docker-airflow 下载镜像：1$ docker pull puckel/docker-airflow 启动：12$ docker run -d -p 8080:8080 puckel/docker-airflow（-d 以后台模式启动，-p 端口映射 主机端口：容器端口） 进入docker：1docker exec -it [container_name] bash 接下来以分析tutorial为例：分析run按钮：点击的script代码如下：这个函数首先组装一个url地址，然后window.location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。12345Id选择器： 以“#”来定义class选择器：以“.”来定义hasClass() 方法检查被选元素是否包含指定的 class，返回true或falseencodeURIComponent() 函数可把字符串作为 URI 组件进行编码，该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * &apos; ( ) ，该函数假定它的参数是 URI 的一部分，因此 encodeURIComponent() 函数将转义用于分隔 URI 各个部分的标点符号。 组装格式如下：1/admin/airflow/run?task_id= &amp;dag_id=&amp;ignore_all_deps &amp;ignore_task_deps= &amp;ignore_ti_state= &amp;execution_date= &amp;origin= 可以通过在web调试窗设断点来找出最终组合的字符串如下形式：123&quot;/admin/airflow/run?task_id=sleep&amp;dag_id=tutorial&amp;ignore_all_deps=false&amp;ignore_task_deps=false&amp;ignore_ti_state=false&amp;execution_date=2017-05-25&amp;origin=http%3A%2F%2F127.0.0.1%3A8080%2Fadmin%2Fairflow%2Fgraph%3Fdag_id%3Dtutorial&quot;&quot;/admin/airflow/success?task_id=templated&amp;dag_id=tutorial&amp;upstream=false&amp;downstream=false&amp;future=false&amp;past=true&amp;execution_date=2017-05-25&amp;origin=http%3A%2F%2F127.0.0.1%3A8080%2Fadmin%2Fairflow%2Fgraph%3Fdag_id%3Dtutorial&quot; 这里我们就找到了airflow前端到后台调用的方式（通过url传参），接下来需要找出如何通过url传参到后台响应： url传参分析：先贴最终结果，airflow使用的是python的flask框架，定义的文件在如下路径的python文件里，从下图中我们可以看到暴露了/run路径，同样的还有success也是以这种方式暴露的1/usr/local/lib/python2.7/dist-packages/airflow/www/views.py 至于如何找到用什么框架方法，是先通过组装好的url的特征字符串比如“run”，然后使用grep命令进行文件内容查找，锁定到views.py文件，然后查看import的库找到所使用的框架，之后我们就可以通过学习框架继续深入研究airflow啦！这是我目前使用的分析逻辑，虽然笨了点，希望对大家能有所帮助，以此抛砖引玉，以后学习更深入了了解的框架更多了，应该能根据经验判断出套用的框架或者调用方式，希望大家有更好的方法能与笔者交流~","updated":"2018-01-21T15:15:56.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"airflow","slug":"airflow","permalink":"http://yoursite.com/tags/airflow/"}]},{"title":"shell常用命令笔记","date":"2017-05-28T16:00:00.000Z","path":"2017/05/29/shell常用命令笔记/","text":"通过 uname -r 命令查看你当前的内核版本:12$ uname -r3.10.0-327.el7.x86_64 vi使用:12345670 移至行首$ 移至行尾u 撤销dd 删除光标所在行u 撤销上一步操作X 向后删除字符x 向前删除字符 运行脚本两种方式：121、source scriptname //这种方式就像直接输入一样2、./scriptname //这种方式脚本运行在子shell find命令：1234567891011121314一般形式为:find pathname -options [-print -exec -ok]例：-name选项：$ find ~ -name &quot;*.txt&quot; -print$ find . -name &quot;[A-Z]*&quot; -print //当前目录及子目录中查找以大写字母开头$ find . -name &quot;[a-z][a-z][0--9][0--9].txt&quot; -print //在当前目录查找文件名以两个小写字母开头,跟着是两个数字,最后是 *.txt的文件$ find /etc -type d -print //-type查找所有的文件夹b - 块设备文件。d - 目录。c - 字符设备文件。p - 管道文件。l - 符号链接文件。f - 普通文件。 grep命令：123456789101112131415161718一般格式为:grep [选项] 基本正则表达式 [文件] //基本正则表达式可为字符串。常用的grep选项有:-c 只输出匹配行的计数，匹配的有几行-i 不区分大小写(只适用于单字符)。-h 查询多文件时不显示文件名。-l 查询多文件时只输出包含匹配字符的文件名。 -n 显示匹配行及行号。-s 不显示不存在或无匹配文本的错误信息。-v 显示不包含匹配文本的所有行例子：$ grep “sort&quot; *.doc$ grep “string&lt;tab&gt;” * //&lt;Tab&gt;表示点击 tab键$ grep ’48[346]’ * //使用 []来指定字符串范围,这里用48开始,以3或4或6结尾$ grep ‘[A-Z][B-Z]..C’ * //匹配头两个是大写字母，以C结尾，中间两位任意 awk命令：1234567动作用&#123;&#125;括起来，if后面的条件用（）括起来awk执行时,其浏览域标记为 $1,$2...$n。这种方法称为域标识。使用$1,$3表示参照第1和第3域，可使用 $0,意即所有域例子：$ awk ‘&#123;print $0&#125;’ grade.txt &gt;test //重定向输出到文件test，此时不显示$ awk ‘&#123;print $0&#125;’ grade.txt | tee test //重定向输出到文件test，并显示到屏幕匹配：使用~紧跟正则表达式$ docker ps -a | awk &apos;&#123;if($2~/p/) print $1&#125;’ // 通过管道找到docker ps -a命令输出中匹配第二列包含p的，然后输出第一列 1234$ awk ‘&#123;if($4~/brown/) print $0&#125;’ grade.txt //匹配第四列包含字符串brown的，然后打印匹配记录行精确匹配用==$ awk &apos;$3==“brown” &#123;print $0&#125;’ grade.txt$ awk ‘&#123;if($4 !~/brown/) print $0&#125;’ grade.txt //不匹配第四列包含字符串brown的，然后打印匹配记录行 sort命令：123456sort -c filename //检查文件是否已分类sort -t: filename //以第1域进行分类(默认)，域分隔符为“:”，默认为空格sort -t: -r filename //-r逆序分类sort -u filename //去除重复行sort -t: -k2 filename //以第2域进行分类sort -k2 -k4 filename //先以第4域,再以第1域分类 ls命令：12ll等价于 ls -l输出文件大小以B为单位 iptables查看及修改防火墙规则：查看规则:123456$ sudo iptables -nL --line-number-L 查看当前表的所有规则，默认查看的是filter表，如果要查看NAT表，可以加上-t NAT参数-n 不对ip地址进行反查，加上这个参数显示速度会快很多-v 输出详细信息，包含通过该规则的数据包数量，总字节数及相应的网络接口–line-number 显示规则的序列号，这个参数在删除或修改规则时会用到 -R参数修改规则:12sudo iptables -R INPUT 5 -j ACCEPTsudo iptables -R FORWARD 1 -j ACCEPT","updated":"2017-01-20T16:00:00.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Mac使用","date":"2017-05-21T16:00:00.000Z","path":"2017/05/22/Mac使用/","text":"关闭端口占用方法：查询PID:1lsof -i:端口号 关闭：kill -9 PID kill网卡进程1sudo killall -9 networkd 快捷键对照：","updated":"2018-01-30T03:50:22.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"Mac使用","slug":"Mac使用","permalink":"http://yoursite.com/tags/Mac使用/"}]},{"title":"VPS调研","date":"2017-05-15T16:00:00.000Z","path":"2017/05/16/VPS调研/","text":"比较：1、 http://blog.csdn.net/zhang_zp2014/article/details/468222632、搬瓦工与vultr及linode三家VPS服务商http://www.bawagon.com/bandwagonvultrlinode/首先价格上搬瓦工实惠，搬瓦工是Openvz系统的VPS，而Vultr及Linode都是KVM系统，性能上比搬瓦工要更好，可操作性更好。因此追求性能的选择Vultr及Linode ,追求价格的可以选择搬瓦工VPS。 Xen、OpenVZ、KVM三大VPS技术优劣势详解基于KVM系统好，能保证内存http://vps.zzidc.com/vpsjishu/452.html VPS服务器全面性能测试：https://www.freehao123.com/vps-cpu-io-unixbench/ VPS主机的CPU详细参数:$ cat /proc/cpuinfo查看内存信息：cat /proc/meminfo测试硬盘读写速度：sudo dd if=/dev/zero of=test bs=1M count=1024 172.104.111.103172.104.111.103ssserver -p 8383 -k 201702 -m rc4-md5 -d start","updated":"2018-01-21T15:11:38.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"vps","slug":"vps","permalink":"http://yoursite.com/tags/vps/"}]},{"title":"微软Coco Framework翻译学习","date":"2017-05-15T16:00:00.000Z","path":"2017/05/16/微软Coco Framework翻译学习/","text":"区块链是一种转型技术，有潜力将数字化转型扩展到公司four walls之外，并进入与供应商，客户和合作伙伴共享的过程。越来越多的企业正在投资区块链，作为一种安全透明的方式，以数字方式跟踪跨越信任边界的资产所有权，并就共享业务流程进行写作，为跨组织协作和富有想象力的新业务模式开创新机遇。 微软致力于为企业提供区块链，并与客户，合作伙伴和区块链社区合作，继续推进企业就绪。我们的使命是通过提供开放，可扩展的平台和服务，帮助企业在这个安全的多方计算的新时代蓬勃发展，任何公司从分类账初创企业到零售商到健康提供商到全球银行都可以用它来改善共享业务流程。 随着企业利用区块链技术来满足其业务需求，他们已经意识到许多现有的区块链协议不能满足关键的企业需求，如性能，机密性，治理和所需的处理能力。这是因为现有的系统被设计来在公开场景最大透明地以匿名，不可信任的角色来实现功能并达成共识。正因为如此，交易被明确地张贴出来供所有人来看，网络中的每个节点都执行每一个交易，并且必须采用计算密集型的共识算法。这些安全措施，虽然是确保公共区块链网络完整所必须的，但会根据重要的企业需求（如可扩展性和机密性）方面进行权衡。 为了适应现有的公共区块链协议或者为了满足这些需求创建新的协议，通常将一个required企业属性交换为另一个，例如以更高的复杂度或更低的性能为代价改进机密性。促进企业区块链采用 今天我很高兴介绍Coco框架，一个开源系统，能够满足所有关键企业需求的高规模，机密的区块链网络，为加快生产企业采用区块链技术提供了一种手段。 Coco通过专门为保密联盟设计来实现这一点，在这些联盟中，节点和角色被明确声明和控制。基于这些需求，Coco 提出一种可替代的方法来构建分类账(ledger)，为企业提供所需的可扩展性，分布式治理和增强的机密性，同时又不牺牲固有的安全性和不变性。 利用现有的区块链协议，可靠执行环节（TEEs）例如Intel SGX and Windows Virtual Secure Mode (VSM)，分布式系统和加密技术，Coco可实现企业就绪区块链网络： 吞吐量和延迟接近数据库速度 更丰富，更灵活的特定业务机密模型 通过分布式治理来实现网络策略管理 支持非确定性交易 通过提高这些功能，Coco提供了一个现有的区块链协议可以集成到一起的可信任的基础，来提供完整的企业级分类账（ledger）解决方案，为各行业开放广阔的，高规模的应用场景，进一步提升区块链的数字化转型业务的能力。 我们已经开始探索Coco在各行业的潜力，包括零售，供应链和金融服务。 “在Coco框架内运行我们现在的供应链Dapp代码能够更快，这是一个巨大的性能改进，当我们和零售客户谈论企业区块链就绪时，这将减少很多摩擦。在不牺牲这种改进的情况下增加数据的机密性支持，能够引导我们用智能供应链设想的数字化转型。” - Tom Racette, Vice President, Global Retail Business Development, Mojix 无论客户是设计一个端到端的贸易金融解决方案，利用区块链来确保边缘安全，还是利用企业智能合约来提高办公效率，Coco都能够满足他们的企业需求。微软是唯一一个提供跨 本地和公有云一致性的云服务商，同时为广大的应用程序提供访问丰富的Azure生态系统，这些应用将被构建在区块链之上作为共享的数据层。 一个open approach 按照设计，Coco是开放的，并且兼容任何区块链协议。微软已经开始将Ethereum整合到Coco中，我们很高兴地宣布J.P. Morgan Chase, Intel and R3已经分别致力于整合enterprise ledgers, Quorum, Hyperledger Sawtooth and Corda。这仅仅是一个开始，我们期待在不久的将来与其他ledgers探索整合机会。 “微软的Coco框架代表了实现高度可扩展的，机密的，以太坊或其他区块链网络的突破，这些区块链网络将成为新兴世界多种互联区块链系统的重要组成部分”。 - Joseph Lubin, Founder of ConsenSys 我相信Coco只能从当今推动区块链创新的多元化和有才华的开源社区中受益。虽然Coco最初是Azure和微软研究院之间的合作，但已经从数十位客户和合作伙伴的投入中受益。开放Coco是一种扩展开发的方式，远超出我们最初工作组的范围和想象，我们的目的是在2018年初向社区贡献代码。 Coco将通过设计和任何ledger协议兼容，并且可以在任何支持兼容TEE的云协议，操作系统和管理程序上运行。我们正在建立这种灵活性，让社区能够将Coco和其他协议集成在一起，在其他硬件上尝试，并将其应用在我们还没想到的企业场景中。 行业对区块链的热情正在增长，虽然区块链还需要时间来实现企业保障，但我们仍然将激光聚焦于与社区合作来加速其发展和企业采用。 要了解有关Coco的更多信息，您可以阅读我们的技术白皮书，并在MSCloud Youtube页面上观看我的demo，请务必在GitHub上star and follow the project，以跟上工作组的进展并接收有关最新进展的通知！","updated":"2018-01-22T01:41:25.000Z","categories":[{"name":"economics","slug":"economics","permalink":"http://yoursite.com/categories/economics/"}],"tags":[{"name":"block-chain","slug":"block-chain","permalink":"http://yoursite.com/tags/block-chain/"},{"name":"Coco","slug":"Coco","permalink":"http://yoursite.com/tags/Coco/"}]},{"title":"Nginx发布网站","date":"2017-04-29T16:00:00.000Z","path":"2017/04/30/Nginx发布网站/","text":"修改配置原理：/etc/nginx/nginx.conf配置文件里的 http 配置区块里，用了一个 include 指令，把所有的在 /etc/nginx/conf.d 这个目录下面的 .conf 文件包含到了这里。include /etc/nginx/conf.d/*.conf;我们如果想去添加自己的配置，可以在/etc/nginx/conf.d 这个目录下新建一个以 .conf 结尾的文件，重新加载 nginx 以后，这些配置就会生效了。 修改/etc/nginx/conf.d下default.conf配置文件123456789server &#123; listen 80 default_server; #监听80端口 server_name wuzhigang.com www.wuzhigang.com; #定义访问的域名 location / &#123; root /home/lijingdong/web; #网站的根目录位置 index 首页.html; #定义首页索引文件名称 &#125;&#125; 保存之后，sudo nginx -t测试配置文件语法是否正确，返回：12nginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful 然后service nginx reload重新加载nginx配置好default.conf文件后,打开网址，显示403forbidden，是由于权限问题，修改nginx.conf文件下第一行为user root;即可","updated":"2018-01-21T15:11:55.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"html+css笔记","date":"2017-04-15T16:00:00.000Z","path":"2017/04/16/html+css笔记/","text":"Html:&lt;b&gt;加粗&lt;p&gt;段落 method 属性:表单数据可以作为 URL 变量（method=”get”）或者 HTTP post （method=”post”）的方式来发送。 浏览器使用 method 属性设置的方法将表单中的数据传送给服务器进行处理。共有两种方法：POST 方法和 GET 方法。 如果采用 POST 方法，浏览器将会按照下面两步来发送数据。首先，浏览器将与 action 属性中指定的表单处理服务器建立联系，一旦建立连接之后，浏览器就会按分段传输的方法将数据发送给服务器。 在服务器端，一旦 POST 样式的应用程序开始执行时，就应该从一个标志位置读取参数，而一旦读到参数，在应用程序能够使用这些表单值以前，必须对这些参数进行解码。用户特定的服务器会明确指定应用程序应该如何接受这些参数。 另一种情况是采用 GET 方法，这时浏览器会与表单处理服务器建立连接，然后直接在一个传输步骤中发送所有的表单数据：浏览器会将数据直接附在表单的 action URL 之后。这两者之间用问号进行分隔。 JSON语法规则: 数据为键/值对 数据由逗号隔开 大括号保存对象 方括号保存数组 函数 描述 JSON.parse() 将JSON字符串转为js对象 JSON.stringify() 将js值转为JSON字符串 代码规范:代码一行太长，建议在 运算符 或 逗号后换行 变量声明时如果不使用var关键字，即使在函数内定义，也是全局变量。 CSS:语法格式：selector {declaration；declaration；}declaration格式属性：[attribute=value] （注意：中间不要留有空格）Id选择器： 以#来定义class选择器：以.来定义 三种颜色定义方式： 十六进制 #ff0000 RGB rgb(255,0,0) 颜色名称 redCSS参考手册","updated":"2017-05-25T16:00:00.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"Javascript笔记","date":"2017-04-15T16:00:00.000Z","path":"2017/04/16/Javascript笔记/","text":"外部调用:1&lt;script src=\"myScript.js\"&gt;&lt;/script&gt; myScript.js 文件代码如下：1function myFunction()&#123; document.getElementById(\"demo\").innerHTML=\"我的第一个 JavaScript 函数\"; &#125; 注：外部脚本不包含&lt;script&gt; 标签 输出：（4种方式）1、 window.alert() 弹出警告框123&lt;script&gt;window.alert(5 + 6);&lt;/script&gt; 2、 document.write() 方法将内容写到 HTML 文档中123&lt;script&gt;document.write(\"&lt;h1&gt;这是一个标题&lt;/h1&gt;\");&lt;/script&gt; 如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖 3、使用 innerHTML 写入到 HTML 元素1document.getElementById(\"demo\").innerHTML=\"My First JavaScript\"; 4、使用 console.log() 写入到浏览器的控制台1console.log(“string\"); 定义变量:var name=&quot;Gates&quot;, age=56, job=&quot;CEO&quot;;如果重新声明 JavaScript 变量，该变量的值不会丢失： 对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔：var person={firstname:&quot;Bill&quot;, lastname:&quot;Gates&quot;, id:5566};对象属性有两种寻址方式：12name=person.lastname;name=person[\"lastname\"]; &lt;button type=&quot;button&quot; onclick=&quot;alert(&#39;欢迎!&#39;)&quot;&gt;点我!&lt;/button&gt; 使用 String 对象的 toUpperCase() 方法来把文本转换为大写： 您会经常看到 document.getElementById(“some id”)。这个方法是 HTML DOM 中定义的。DOM (Document Object Model)（文档对象模型）是用于访问 HTML 元素的正式 W3C 标准。1234567&lt;script&gt;function changeImage()&#123;&#125;&lt;/script&gt;&lt;img id=\"myimage\" onclick=\"changeImage()\"src=\"/images/pic_bulboff.gif\" width=\"100\" height=\"180\"&gt; 改变 HTML 元素的样式:x=document.getElementById(&quot;demo&quot;) // 找到元素x.style.color=&quot;#ff0000&quot;; // 改变样式 获取输入框内容：12&lt;input id=\"demo\" type=\"text”&gt; //输入框创建var x=document.getElementById(\"demo\").value; 注释：123//单行/*多行*/ JavaScript 对大小写是敏感的 对代码行进行折行：您可以在文本字符串中使用反斜杠对代码行进行换行。下面的例子会正确地显示：document.write(&quot;你好 \\世界!&quot;);不过，您不能像这样折行：document.write \\(&quot;你好世界!&quot;); 常见的HTML事件的列表: 事件 描述 onchange HTML 元素改变 onclick 用户点击 HTML 元素 onmouseover 用户在一个HTML元素上移动鼠标 onmouseout 用户从一个HTML元素上移开鼠标 onkeydown 用户按下键盘按键 onload 浏览器已完成页面的加载 基于某些条件对变量进行赋值:variablename=(condition)?value1:value2例如：123456789101112voteable=(age&lt;18)?\"年龄太小\":\"年龄已达到\";time 当前24小时制整点数字 例如2 15if (condition1)&#123;&#125;else if (condition2)&#123;&#125;else&#123;&#125; 改变HTML内容：123456789通过id查找 HTML 元素:var x=document.getElementById(\"main\");通过标签名查找 HTML 元素:var x=document.getElementById(\"main\");var y=x.getElementsByTagName(\"p\");通过类名查找 HTML 元素:x=document.getElementsByClassName(\"intro\"); 改变HTML属性：1document.getElementById(id).属性标签=新属性值 改变HTML样式：123document.getElementById(id).style.property=新样式例如：document.getElementById(\"p2\").style.color=\"blue\";","updated":"2017-05-25T16:00:00.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"docker学习整理","date":"2017-04-14T16:00:00.000Z","path":"2017/04/15/dockerStudy/","text":"1docker version：查看docker的版本号，包括客户端、服务端、依赖的Go等 1docker info ：查看系统(docker)层面信息，包括管理的images, containers数等 查找镜像，可做模糊搜索1docker search &lt;image&gt;：在docker index中搜索image 下载镜像1docker pull &lt;image&gt; ：从docker registry server 中下拉image 查看镜像12docker images： 列出imagesdocker images -a ：列出所有的images（包含历史） 删除镜像或容器：1234docker rmi &lt;image ID&gt;： 删除一个或多个imagedocker rm &lt;container ID&gt;： 删除一个或多个containerdocker rm `docker ps -a -q` ：删除所有的containerdocker ps -a -q | xargs docker rm ：同上, 删除所有的container 使用镜像创建容器12345678docker run [options] [image]options:-d 以后台方式运行-p 指定端口映射 -p &lt;host_port:contain_port&gt;docker run -d -p 8080:8080 puckel/docker-airflow-i -t 一般同时使用，在新容器内指定一个伪终端或终端，并允许进行交互docker run -i -t centos:6.9 /bin/bash :使用镜像centos:6.9创建container并进入交互模式, login shell是/bin/bash 查看容器:1234docker ps ：列出当前所有正在运行的containerdocker ps -l ：列出最近一次启动的containerdocker ps -a ：列出所有的container（包含历史，即运行过的container）docker ps -q ：列出最近一次运行的container ID 开启/停止/重启/连接container:12docker start/stop/restart &lt;container&gt; :注：使用start是启动已经创建过得container，使用run则通过image开启一个新的container。docker attach [container_id] ：连接一个正在运行的container实例（即实例必须为start状态，可以多个窗口同时attach一个container实例） 通过容器生成新的镜像1docker commit &lt;container&gt; [repo:tag] 将一个container固化为一个新的image，后面的repo:tag可选。 容器备份、恢复和迁移：docker的备份方式有export和save两种。export备份：1234export是当前的状态，针对的是容器，docker save 是针对镜像images。 $ docker export [CONTAINER ID] &gt;export.tar //export是把容器打成一个tar包。import恢复： $ cat export.tar | docker import - repo:tag save备份： 12345 $ docker save repo:tag &gt;save.tar恢复镜像: $ docker load &lt;save.tar对image打tag$ docker tag imageID repo:tag 两者的区别: 导出后再导入(exported-imported)的镜像会丢失所有的历史，而保存后再加载（saveed-loaded）的镜像没有丢失历史和层 (layer)。这意味着使用导出后再导入的方式，你将无法回滚到之前的层(layer)，同时，使用保存后再加载的方式持久化整个镜像，就可以做到层回滚（可以执行docker tag 来回滚之前的层）。","updated":"2018-01-21T15:11:26.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"docker下centos6.9镜像安装jira及破解完整操作记录","date":"2017-04-13T16:00:00.000Z","path":"2017/04/14/docker下centos6.9镜像安装jira及破解完整操作记录/","text":"说明：以下操作命令中以$开头的是在主机终端下操作的，以#开头的是在容器交互终端下操作的，即docker镜像系统centos6.9，所需文件在这里,下文中拷贝命令的时候注意使用mkdir命令建立相对应的文件夹~1.下载docker mac版2.在https://hub.docker.com/explore/上查找镜像， 也可以使用 docker search 命令来搜索镜像。 docker search ：在docker index中搜索image,例如1$ docker search centos 红色箭头显示为官方版本 我们选择官方版本，但是可以通过选择版本标签来匹配安装版本，例如： docker pull centos:5.11 or docker pull centos:6.6 3.下载cantos6.9版本的镜像1$ docker pull centos:6.9 之后打开进入容器：1$ docker run -i -t centos:6.9 /bin/bash -t:在新容器内指定一个伪终端或终端。-i:允许你对容器内的标准输入 (STDIN) 进行交互。 查看系统版本 1# cat /etc/redhat-release 4.安装mysql1# yum install -y mysql-server mysql -y代表自动选择y 5.安装完成以后启动mysql1# /etc/init.d/mysqld start 6.验证安装成功1mysql&gt; show databases; 7.安装jdk1$ mkdir java 8.mac主机中查看docker容器ID：1$ docker ps 使用cp命令把主机的文件拷贝到docker容器：格式：1$ docker cp /Users/peanut/Documents/Data\\ Study/jdk-8u121-linux-x64.tar containerID:/home/java/jdk-8u121-linux-x64.tar 9.容器交互终端下解压：1# tar -xvf jdk-8u121-linux-x64.tar 配置环境：1# vi /etc/profile 文件最后添加以下内容：1234JAVA_HOME=/home/java/jdk1.8.0_121CLASSPATH=$JAVA_HOME/lib:$JAVA_HOME/jre/libPATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/binexport PATH CLASSPATH JAVA_HOME 这样JDK就设置好了，然后以下命令使其生效：12# source /etc/profile# echo $JAVA_HOME 验证java的路径 10.拷贝jira安装包到容器1$ docker cp /Users/peanut/Documents/Data\\ Study/atlassian-jira-6.3.6.tar containerID:/home/jira/atlassian-jira-6.3.6.tar 解压1# tar -xvf atlassian-jira-6.3.6.tar jira的8005和8080端口都重新修改一下，在server.xml中，我的修改为8007和8099了，修改方法如下:1#vi jira/atlassian-jira-6.3.6-standalone/conf/server.xml 在其中找到8005和8080进行修改接着在atlassian-jira-6.3.6-standalone文件同目录下创建一个文件夹：jira_home，修改配置文件 1# vi /home/jira/atlassian-jira-6.3.6-standalone/atlassian-jira/WEB-INF/classes/jira-application.properties 修改为如下内容：1jira.home = /home/jira/jira_home 启动jira服务： 1# /home/jira/atlassian-jira-6.3.6-standalone/bin/start-jira.sh 11.1# mysql -u root -p 默认无密码创建数据库jiradb：1mysql&gt; create database jiradb character set gbk; 创建用户并赋予权限：12345mysql&gt; create user jirauser identified by &apos;password&apos;;&gt; GRANT ALL ON jiradb.* TO &apos;jirauser&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos; with grant option;&gt; flush privileges; 12.在JIRA的数据目录下删除文件：dbconfig.xml,删除这个文件再重启jira后就可以重新看到初始配置界面，这里可不执行这一步~1# rm -f /home/lijingdong/jira/jira_home/dbconfig.xml 13.重新启动JIRA服务启动：1# /home/jira/atlassian-jira-6.3.6-standalone/bin/start-jira.sh 停止：1# /home/jira/atlassian-jira-6.3.6-standalone/bin/shutdown.sh 14.记下容器ID,然后1$ exit 退出容器 15.docker commit 命令创建新镜像：1$ docker commit containerID centos6/jira:1.0 注意，如果不commit创建新镜像，之前的修改就都没了！1$ docker images查看新创建的镜像： 16.重启镜像，并将端口8099映射到主机的8099端口：1$ docker run -i -t -p 8099:8099 centos6/jira:1.0 /bin/bash 此时需重新启动mysql，重新source JAVA_HOME，重新启动jira：123# /etc/init.d/mysqld start# source /etc/profile# /home/jira/atlassian-jira-6.3.6-standalone/bin/start-jira.sh 然后打开0.0.0.0:8099即可看到jira 17.jira破解:将atlassian-universal-plugin-manager-plugin-2.17.13.jar复制到容器上/home/jira/atlassian-jira-6.3.6-standalone/atlassian-jira/WEB- INF/atlassian-bundled-plugins/下： 12$ docker cp /Users/peanut/Documents/Data\\ Study/atlassian-universal-plugin-manager-plugin-2.17.13.jar containerID:/home/jira/atlassian-jira- 6.3.6-standalone/atlassian-jira/WEB-INF/atlassian-bundled-plugins/ 将破解文件atlassian-extras-2.2.2.jar复制到容器上/home/lijingdong/jira/atlassian-jira-6.3.6-standalone/atlassian-jira/WEB-INF/lib/目录下替换同名文件:12$ docker cp /Users/peanut/Documents/Data\\ Study/atlassian-extras-2.2.2.jar containerID:/home/jira/atlassian-jira-6.3.6-standalone/atlassian- jira/WEB-INF/lib 之后重启jira。点击右上角齿轮形状的管理图标，选择“系统”，再选择“授权”，看到使用日期不到1个月，如下所示：填写授权码，授权码参数范例如下：123456789101112131415Description=JIRA: Commercial,CreationDate=你的安装日期，格式（yyyy-mm-dd）,jira.LicenseEdition=ENTERPRISE,Evaluation=false,jira.LicenseTypeName=COMMERCIAL,jira.active=true,licenseVersion=2,MaintenanceExpiryDate=你想设置的失效日期如：2099-12-31,Organisation=joiandjoin,SEN=你申请到的SEN注意没有前缀LID,ServerID=你申请到的ServerID,jira.NumberOfUsers=-1,LicenseID=LID你申请到的SEN，注意LID前缀不要丢掉,LicenseExpiryDate=你想设置的失效日期如：2099-12-31,PurchaseDate=你的安装日期，格式（yyyy-mm-dd） 破解完成:18.docker容器跨服务器迁移： 有两种方法，我们使用save方式:备份：1$ docker save centos6/jira:2.0 &gt;centos6_jira.tar 使用scp命令将文件拷贝到远程服务器上：1$ scp /Users/peanut/Documents/Data\\ Study/centos6_jira.tar user@serverIP:/home/user 恢复： 1$ docker load &lt;centos6_jira.tar 查看恢复的镜像： 1$ docker images","updated":"2018-01-21T15:11:32.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"},{"name":"jira","slug":"jira","permalink":"http://yoursite.com/tags/jira/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"丑奴儿·书博山道中壁","date":"2017-03-31T09:02:23.000Z","path":"2017/03/31/丑奴儿/","text":"少年不识愁滋味，爱上层楼。爱上层楼，为赋新词强说愁。而今识尽愁滋味，欲说还休。欲说还休，却道天凉好个秋。","updated":"2018-01-21T15:10:45.000Z","categories":[{"name":"think","slug":"think","permalink":"http://yoursite.com/categories/think/"}],"tags":[]},{"title":"西洲曲","date":"2017-03-31T09:01:12.000Z","path":"2017/03/31/西洲曲/","text":"忆梅下西洲，折梅寄江北。单衫杏子红，双鬓鸦雏色。西洲在何处？两桨桥头渡。日暮伯劳飞，风吹乌臼树。树下即门前，门中露翠钿。开门郎不至，出门采红莲。采莲南塘秋，莲花过人头。低头弄莲子，莲子清如水。置莲怀袖中，莲心彻底红。忆郎郎不至，仰首望飞鸿。鸿飞满西洲，望郎上青楼。楼高望不见，尽日栏杆头。栏杆十二曲，垂手明如玉。卷帘天自高，海水摇空绿。海水梦悠悠，君愁我亦愁。南风知我意，吹梦到西洲。","updated":"2018-01-21T15:10:11.000Z","categories":[{"name":"think","slug":"think","permalink":"http://yoursite.com/categories/think/"}],"tags":[]},{"title":"git个人博客使用","date":"2017-03-25T16:00:00.000Z","path":"2017/03/26/git个人博客使用/","text":"步骤： 在source文件夹相应分类目录下写.md文件 在每个分类目录下将索引按格式要求写入index.md文件 根目录下执行命令1$ hexo g -d markdown语法参考链接123---title: *******--- 抬头部分还支持的其他参数： markdown支持html语法加颜色（类似于html的语法）：1&lt;font color=#ff0000&gt;内容部分&lt;/font&gt; 修改字体：12&lt;font face=\"手札体-简\"&gt;内容部分&lt;/font&gt; 添加图片：12![](/img/airflow/run.png)这里的根路径是指source文件夹 添加超链接123[文字](http://********)例：[CSS参考手册](http://www.w3school.com.cn/cssref/css_selectors.asp)","updated":"2018-01-20T16:00:00.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}]},{"title":"w3m文字浏览器基本操作","date":"2017-03-17T16:00:00.000Z","path":"2017/03/18/w3m文字浏览器基本操作/","text":"安装：1$ yum install w3m 以网址启动w3m：1$ w3m www.baidu.com 这时打开网页，且处于交互模式下，可输入命令进行操作： 基本操作：1234567891011121314151617181920H 显示帮助信息j,k,h,l(或上下左右方向键) 移动光标space 向下翻页b 向上翻页&lt;,&gt; 用来左右滚屏tab 移动到下一个超链接T 新建标签页，和当前页面相同，相当于复制B 返回前一个页面，后退U 重新输入需要打开的网址ctrl+t 在新标签页打开光标所在超链接&#123;，&#125; 在标签页间左右切换/ 向后查找当前页面？ 向前查找当前页面n 查找下一个已查找过的关键字N 向前查找已查找过的关键字m 切换鼠标控制方式ctrl+q 关闭当前标签页q 退出w3m浏览器搜索： 在需要输入的文本框内按回车enter，下面就会出现TEXT: ，这时你可以输入你要搜索的文字。再按回车就是返回给文本框。这时再把光标移到”百度搜索”的那个按键，回车，就可以开始搜索了！","updated":"2018-01-21T15:05:23.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"w3m","slug":"w3m","permalink":"http://yoursite.com/tags/w3m/"}]},{"title":"bash命令行处理步骤及源码解析","date":"2017-03-15T16:00:00.000Z","path":"2017/03/16/bash命令行处理步骤及源码解析/","text":"之前在执行脚本时发现一个问题： 12345$ cat a.sh#!/bin/bashOPTS=&quot;--conf javaOption=\\&quot;-Da=b -Dc=d\\&quot;&quot;eval ./c.sh $OPTS./c.sh $OPTS 1234567$ cat c.sh#!/bin/bashn=$#for ((i=0; i&lt;n; i++));do echo &quot;$i:&#123;&quot;$1&quot;&#125;&quot; shiftdone 对于加eval和不加eval处理的./c.sh $OPTS命令结果是不一样的，而且直接的./c.sh $OPTS得出的并不是我们想要的结果:123456789一、eval ./c.sh $OPTS结果：0:&#123;--conf&#125;1:&#123;javaOption=-Da=b -Dc=d&#125;二、./c.sh $OPTS结果：0:&#123;--conf&#125;1:&#123;javaOption=&quot;-Da=b&#125;2:&#123;-Dc=d&quot;&#125; 为了说明这个问题，我研究了一下bash命令行处理的流程，为什么会出现这种差别，以下分为两步来说明：（1）说明bash命令行处理流程；（2）使用grep命令+log打印+gdb+xcode来重新调试源码，从源码里解释流程。在这里贴出官方源码下载地址，此处我使用的版本是bash4.4 首先来说一下bash命令行处理流程，分为12步，来自《学习bash》这本书中，流程图如下：对于一行bash命令的执行流程分为两大步骤：解析和执行。 解析的作用是获得用于执行的命令结构体：COMMAND *global_command执行主要是针对特定类型的命令进行执行和结果处理，我们主要看解析过程。 解析bash的入口函数main()位于文件shell.c中12345678910111213141516intmain (argc, argv, env) int argc; char **argv, **env;&#123; .... shell_initialize (); .... run_startup_files (); .... shell_initialized = 1; /* Read commands until exit condition. */ reader_loop (); exit_shell (last_command_exit_value);&#125; main函数前部分主要做初始化工作，初始化完成之后，进入eval.c中的交互循环函数reader_loop()（shell.c中799行）。该函数不断读取和执行命令，直到遇到EOF。此时函数调用关系为：main()–&gt;reader_loop()。 123456789101112131415161718/* Read and execute commands until EOF is reached. This assumes that the input source has already been initialized. */intreader_loop ()&#123; .... if (read_command () == 0) &#123; .... &#125; else if (current_command = global_command) &#123; .... execute_command (current_command); &#125; .... return (last_command_exit_value);&#125; reader_loop()函数中调用read_command()取得命令结构体global_command，然后赋值给current_command并交给execute_command ()去执行。 read_command ()调用parse_command ()，此时函数调用关系为：main()–&gt;reader_loop()–&gt;read_command()–&gt;parse_command() 123456789101112131415161718192021222324252627/* Read and parse a command, returning the status of the parse. The command is left in the globval variable GLOBAL_COMMAND for use by reader_loop. This is where the shell timeout code is executed. */intread_command ()&#123; .... result = parse_command (); .... return (result);&#125;..../* Call the YACC-generated parser and return the status of the parse. Input is read from the current input stream (bash_input). yyparse leaves the parsed command in the global variable GLOBAL_COMMAND. This is where PROMPT_COMMAND is executed. */intparse_command ()&#123; .... r = yyparse (); if (need_here_doc) gather_here_documents (); return (r);&#125; parse_command()调用y.tab.c中的yyparse ()函数，并使用函数gather_here_documents ()处理here document类型的输入重定向。 yyparse ()由YACC通过parse.y生成，函数内使用大量的goto语句，可读性较差： 12345678910111213141516171819202122232425262728293031323334intyyparse ()&#123; .... yychar = YYLEX; .... yytoken = YYTRANSLATE (yychar); .... yyn += yytoken; .... switch (yyn) &#123; case 2: &#123; global_command = (yyvsp[(1) - (2)].command); .... &#125; break; case 3: &#123; global_command = (COMMAND *)NULL; .... &#125; break; .... case 6: &#123; (yyval.word_list) = make_word_list ((yyvsp[(1) - (1)].word), (WORD_LIST *)NULL); &#125; break; .... default: break; &#125; .... return YYID (yyresult);&#125; 函数内调用yylex()(宏定义：#define YYLEX yylex ())来获得并计算出整型变量yyn的值，然后根据不同的yyn值获取具体的命令结构体。 在函数yylex()内部，调用read_token()获得各种类型的token并进一步调用read_token_word()获取具体的不同类型的单词结构WORD_DESC。 之后在yyparse()中，调用文件make_cmd.c中各种函数，根据yylex()获得的各种token和word组装成具体command。 此时的函数调用关系为： main()–&gt;reader_loop()–&gt;read_command()–&gt;parse_command()–&gt;yyparse()–&gt;yylex()–&gt;read_token()——&gt;read_token_word()————&gt;global_command 下边来举个例子例1，这是我在下载的bash源码中添加了printf编译后的一个简单命令执行的输出，其中的每个名词都是源码里的函数名，如果需要找到所在文件，我们可以使用grep命令，例如grep -n “reader_loop” *(其中-n代表标出所在行数，*代表在该文件夹下的所有文件中查找,更详细的grep用法大家可以查看linux shell编程指南)：12345678910111213141516171819202122232425262728293031323334353637$ cat test1.sh./c.sh --conf javaOption=\"-Da=b -Dc=d\"$ ../bash-4.4/bash test1.shreader_loopread_commandparse_commandyyparseStarting parse[Function]read_tokenreserved_word_acceptableCHECK_FOR_RESERVED_WORDreserved_word_acceptablereserved_word_acceptable[Function]read_tokenreserved_word_acceptableCHECK_FOR_RESERVED_WORDreserved_word_acceptablereserved_word_acceptable[Function]read_tokenreserved_word_acceptableCHECK_FOR_RESERVED_WORDreserved_word_acceptablereserved_word_acceptable[Function]read_tokenexpand_wordsbrace_expansion //大括号扩展shell_expand_word_list //5-8步string_extract_double_quoted //双引号处理-Da=b -Dc=ddequote_string-Da=b -Dc=dquote_stringdequote_stringdequote_stringdequote_string0:&#123;--conf&#125;1:&#123;javaOption=-Da=b -Dc=d&#125; 上边的输出基本对应12步处理流程，接下来我们具体深入分析： 首先看两个执行结果： 脚本内容：12OPTS=&quot;--conf javaOption=\\&quot;-Da=b -Dc=d\\&quot;&quot;./c.sh $OPTS 执行结果如下：1230:&#123;--conf&#125;1:&#123;javaOption=&quot;-Da=b&#125;2:&#123;-Dc=d&quot;&#125; 脚本内容： 1./c.sh --conf javaOption=&quot;-Da=b -Dc=d&quot; 执行结果如下： 120:&#123;--conf&#125;1:&#123;javaOption=-Da=b -Dc=d&#125; 这里第一个脚本未对双引号进行处理，为什么呢？出现这种不同，主要是在于命令行处理流程中对于双引号的处理位置。在命令行处理流程中,位于subst.c文件9017（大约位置，因为加log信息后有变）处的函数 expand_word_internal()是处理从第五步波浪号扩展到第八步算术替换的核心函数，而实际对于双引号的处理是在与这几步变换并列的一个switch语句里，bash在处理完$相关的扩展之后会直接跳出switch，所以就跳过了关于双引号的处理，也就是说switch语句里case的顺序是$符号的相关扩展在前，双引号处理的在后。至于我是如何找到的呢，在这里也贴出来供大家参考，少走弯路：在例1中我们可以看到根据log信息我们已经发现了双引号处理的函数是string_extract_double_quoted，那么我们接下来要做的就是找到string_extract_double_quoted()函数是如何从read_loop()函数一路被调用的，所以现在我们使用gdb,调试命令如下：(当前我们在bash-4.4文件夹下，a.sh相对路径bash-4.4/task/a.sh)1234567891011121314151617181920212223242526272829[task]$ cat a.sh#!/bin/bash./task/c.sh --conf javaOption=\"-Da=b -Dc=d\"[task]$ cd ..[bash-4.4]$ gdb bash//此时进入到gdb调试模式下(gdb) b subst.c:841 //在subst.c的841行添加断点，也就是string_extract_double_quoted()函数所在的位置Breakpoint 1 at 0x453f91: file subst.c, line 841. (gdb) r task/a.sh //运行a.shStarting program: /home/lijingdong/task/bash-4.4/bash task/a.shBreakpoint 1, string_extract_double_quoted ( string=0x720b08 \"javaOption=\\\"-Da=b -Dc=d\\\"\", sindex=0x7fffffffdf7c, flags=&lt;value optimized out&gt;) at subst.c:841841 string_extract_double_quoted (string, sindex, flags)Missing separate debuginfos, use: debuginfo-install glibc-2.12-1.166.el6_7.7.x86_64(gdb) bt#0 string_extract_double_quoted ( string=0x720b08 \"javaOption=\\\"-Da=b -Dc=d\\\"\", sindex=0x7fffffffdf7c, flags=&lt;value optimized out&gt;) at subst.c:841 //在这里我们就可以看到函数的调用次序了，是 //expand_word_internal函数直接调用了str //ing_extract_double_quoted函数来进行双 //引号处理#1 0x000000000045983f in expand_word_internal (word=0x720ae8, quoted=0, isexp=0, contains_dollar_at=0x7fffffffe088, expanded_something=0x7fffffffe08c) at subst.c:9443#2 0x000000000045b29a in shell_expand_word_list (list=&lt;value optimized out&gt;, eflags=31) at subst.c:10569#3 expand_word_list_internal (list=&lt;value optimized out&gt;, eflags=31) at subst.c:10692 接下来我们只要用grep命令找到expand_word_internal函数进行具体分析即可： 在subst.c中添加的log信息如下： 对于./c.sh $OPTS的执行过程中打印：[DEBUG] word: ./c.sh[DEBUG] word: $OPTS[DEBUG]\\$ begin substitute //在这里执行\\$OPTS的参数扩展[DEBUG]\\$ end substitute之后直接跳出switch循环了。 而对于./c.sh –conf javaOption=”-Da=b -Dc=d”的执行过程中打印：[DEBUG] word: ./task/c.sh[DEBUG] word: –conf[DEBUG] word: javaOption=”-Da=b -Dc=d”[DEBUG]double_quote processing //处理双引号[DEBUG] word: -Da=b -Dc=dDetaching after fork from child process 14855.0:{–conf}1:{javaOption=-Da=b -Dc=d}&#8194;&#8194;&#8194;&#8194;在接下来的switch里边会处理到双引号，调用string_extract_double_quoted()函数将引号内字符串处理为一个整体。&#8194;&#8194;&#8194;&#8194;写到这里也就差不多结束啦，bash源码的解读还有很多需要研究的地方，目前我还只是因为eval命令的原因研究了bash中关于双引号的处理，以此来作为一个引子，也给各位跟我一样的新手提供一个编译调试，解读源码的完整思路，如果大家有什么问题或者文中有什么错误，还请多多指正，多多交流~","updated":"2018-01-21T15:17:24.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"centos+shadowsocks科学上网","date":"2017-02-27T16:00:00.000Z","path":"2017/02/28/centos+shadowsocks科学上网/","text":"像centos这类衍生出来的发行版，他们的源有时候内容更新的比较滞后，或者说有时候一些扩展的源根本就没有。所以在使用yum来search python-pip的时候，会说没有找到该软件包。因此为了能够安装这些包，需要先安装扩展源EPEL 首先安装epel扩展源：1$ sudo yum -y install epel-release 然后安装python版本的pip：1$ sudo yum -y install python-pip 安装shadowsocks：1$ pip install shadowsocks 在/etc目录下创建shadowsocks.json配置文件:1$ vi /etc/shadowsocks.json 输入以下内容：12345678910&#123; &quot;server&quot;:&quot;你的服务器IP，是VPS的哦&quot;, &quot;port_password&quot;:&#123; &quot;8381&quot;:&quot;随意设定8381端口使用密码&quot;, &quot;8382&quot;:&quot;随意设定8382端口使用密码&quot;, &quot;8383&quot;:&quot;随意设定8383端口使用密码&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;此处为加密方式 &#125; 以上设置了三个用户，每个端口对应一个用户 之后启动shadowsocks1$ ssserver -c /etc/shadowsocks.json -d start 可以使用netstat -lnp查看对应端口有没有开始监听，如图服务器端就结束了，之后在客户端安装shadowsocks配置好服务器即可。","updated":"2018-01-21T15:17:01.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://yoursite.com/tags/shadowsocks/"}]},{"title":"实验室成果","date":"2017-02-08T16:00:00.000Z","path":"2017/02/09/实验室成果/","text":"文章1: 学术专著:邢飞，尤政，孙婷等《APS CMOS星敏感器系统原理及实现方法》，国防工业出版社 2017； 2: 学术专著的一章：尤政等著《空间微系统与微纳卫星》第五章《先进空间光学姿态敏感器技术》，国防工业出版社 2013； 3: Geng Wang, Fei Xing, Minsong Wei, Ting Sun, Zheng You. Optimization method for star tracker orientation in the sun-pointing mode[J]. Chinese Optics Letters, 2017, 15(8)(SCI). 4: Geng Wang, Fei Xing, Minsong Wei, Ting Sun, Zheng You. Optimization method of star tracker orientation for sun-synchronous orbit based on space light distribution[J]. Applied Optics, 2017, 56(15)(SCI). 5: Sun Ting, Xing Fei, Wang Xiaochu, et al. Effective star tracking method based on optical flow analysis for star trackers[J]. Applied Optics, 2016, 55(36): 10335-10340. 6: Li J, Xing F, Chu D, et al. High-Accuracy Self-Calibration for Smart, Optical Orbiting Payloads Integrated with Attitude and Position Determination[J]. Sensors, 2016, 16(8): 1176. 7: Minsong wei, Fei Xing, Zheng You, A highly accurate wireless digital sun sensor based on profile detecting and detector multiplexing technologies[J]. Mechanical Systems and Signal Processing, 2017, 82: 56-67 8: Sun T, Xing F, Wang X, et al. An accuracy measurement method for star trackers based on direct astronomic observation[J]. Scientific reports, 2016, 6: 22593 9: Wang Geng, Xing Fei* et al. “Precision enhancement method for multiplexing image detector-based sun sensor with varying and coded apertures.” Applied Optics 54.35 (2015): 10467-10472. 10: Special Issue: Xing Fei, Smart Optical Instruments and Systems for Space Applications. [J] Instrumentation, 2015 Vol 1. 11: Li Jin， Xing Fei*, Sun Ting, You Zheng, Space high accuracy intelligence payload system with integrated attitude and position determination. Instrumentation, Vol 2, No.1 P3-17 March 2015. 12: Sun Ting, Xing Fei*, You Zheng, Research on Dynamic Performance of Star tracker. Instrumentation, Vol 2, No.1, P18-26 March 2015. 13: Wei Minsong, Xing Fei*, Wang Geng, You Zheng, System modeling based measurement error analysis of digital sun sensors. Instrumentation, Vol 2, No.1 P27-P32, March 2015. 14: Liu Zengyi, Zhaoborui, Fei Xing, Design and error analysis of a high accurate star simulator based on optical splicing technology. Instrumentation, Vol 2, No.1 P44-56, March 2015 15: Li jin， Xing Fei*, Sun Ting, You Zheng, Efficient assessment method of on-board modulation transfer function of optical remote sensing sensors. [J] Optics Express, 2015, 23(5):6187-6208. 16: Wang Hongjian, Xing Fei*, You Zheng, Chu Daping, Study on a High-precision Earth Sensor with Triple-FOV. [J], Instrumentation, 2014, 2: 003. 17: Wei Minsong, Xing Fei*, You Zheng, et al. Multiplexing image detector method for digital sun sensors with arc-second class accuracy and large FOV. [J] Optics Express, 2014, 22(19): pp.23094-23107. SCI, IF=3.525, WOS:000342756500084, IDS: AQ4IB，SCI&amp;SCI-E 18: Sun Ting, Xing Fei*, You Zheng, et al. Deep coupling of star tracker and MEMS-gyro data under high dynamic and long exposure conditions. [J] Measurement Science and Technology, 2014, 25(8), 085003. SCI, IF =1.352, WOS:000339273800013, IDS: AL6WJ, SCI &amp;SCI-E 19: Sun Ting, Xing Fei*, You Zheng, et al. Smearing model and restoration of star image under conditions of variable angular velocity and long exposure time. [J] Optics Express, 2014, 22(5): 6009-6024. SCI, IF=3.525, WOS:000333579200153, IDS: AD9IS, Citation:2, other citations:1, web of science:1, SCI &amp;SCI-E 20: Wang Chong，You Zheng，Xing Fei* , et al. Optical Flow Inversion for Remote Sensing Image Dense Registration and Sensor’s Attitude Motion High-Accurate Measurement. [J] Mathematical Problems in Engineering, 2014(2014): 432613. SCI, IF=1.082; WOS:000330440500001; IDS: 300BX, SCI-E 21: Li Jin, Xing Fei *,You Zheng, Compression of Multispectral Images with Comparatively Few Bands Using Posttransform Tucker Decomposition. [J] Mathematical Problems in Engineering, 2014(2014): 296474. SCI, IF=1.082, WOS:000342933000001， IDS：AQ6OF, SCI-E 22: Li jin, Xing Fei*, Sun Ting, You Zheng. Multi-band CCD Image Compression for Space Camera with Large Field of View. [J] Journal of Applied Mathematics, 2014(2014), 374285 SCI, IF=0.834;???? 23: Li jin, Xing Fei*, Sun Ting, You Zheng. An Efficient Image Compressor for Charge Coupled Devices (CCD) Camera. [J] The Scientific World Journal, 2014(2014), 840762. SCI, IF=1.220. WOS:000343547500001, IDS: AR4HG, SCI-E 24: Li Jin, Xing Fei*, Sun Ting, You, Zheng, Multispectral Image Compression Based on DSC Combined with CCSDS-IDC. [J] The Scientific World Journal, 2014(2014), 738735 SCI, IF=0.834; WOS:000343516900001, IDS: AR3VM, SCI-E 25: Sun Ting, Xing Fei*, et al. Motion-blurred star acquisition method of the star tracker under high dynamic conditions. [J] Optics Express 2013, 21(17): 20096-20110. IF=3.525, WOS:000323830500064, IDS：210KD，Citations：7, other citations: 2, web of science: 5, other web of science: 0, SCI &amp;SCI-E 26: Wei Minsong, Xing Fei*, You Zheng et al. An implementation method based on ERS imaging mode for sun sensor with 1 kHz update rate and 1 ″precision level. [J] Optics Express, 2013, 21(26): 32524-32533. IF=3.525, WOS:000329205200079, IDS: 282WP, Citations：1，other citations:0,web of science:1 SCI&amp; SCI-E 27: Xing Fei*, Zhao borui, Shi Wenying et al. Study on Tunable Fabrication of the Ultra-black Ni–P Film and its Blacking Mechanism. [J] Electrochimica Acta, 2013, 100: 157-163. IF=4.086, WOS:000320492400021, IDS：165OE, Citations:5, other citations:5,web of science:4, other web of science:4, SCI &amp;SCI-E 28: Sun Ting, Xing Fei*, and You Zheng. Optical System Error Analysis and Calibration Method of High-Accuracy Star Trackers. [J] Sensors 2013, 13(4): 4598-4623. IF=2.048， WOS:000318036400037, IDS：131ZC, Citations:13, other citations:8, web of science: 10, other web of science: 6 SCI-E 29: Chen Nan, and Xing Fei*, A New Approach to Determine the Centroid of Star Spot for Star Tracker Based on MEMS-Gyro. [J] Key Engineering Materials 2013, 562: 350-356. Citations:1, other citations:0,web of science:1, other web of science:0 30: Xing Fei*, Chen Nan et al. A Novel Approach Based on MEMS-Gyro’s Data Deep Coupling for Determining the Centroid of Star Spot. [J] Mathematical Problems in Engineering 2012(2012). IF=1.082, WOS:000309005400001,IDS:009DI, citations:3, other citations:0, web of science:3, other web:0, SCI-E 31: Wei, Minsong, Xing Fei*, Li, Bin. Investigation of Digital Sun Sensor Technology with an N-Shaped Slit Mask. [J] Sensors, 2011, 11: 9764-9777. IF=2.048, WOS:000296577000039, IDS: 842FC, citations:7, other citations:4, web of science: 4, other web:3, SCI-E 32: Xing Fei*, et al. A novel active pixels sensor (APS) based sun sensor based on a feature extraction and image correlation (FEIC) technique. [J] Measurement Science and Technology, 2008,19(12): 125203. IF=1.352, WOS:000260759000007, IDS:370JR, citations:7, other citations: 2, web of science: 5, other web:1, SCI&amp;SCI-E 33: Xing Fei*, Dong Ying, and You Zheng. Laboratory calibration of star tracker with brightness independent star identification strategy. [J] Optical Engineering, 2006, 45(6): 063604-063604. IF=0.958, WOS:000239345200016, IDS:068AY, citations:18, other citations:9, web of science:10, other web:5, SCI&amp;SCI-E 34: You Zheng, Sun Jian, Xing Fei, et al. A novel multi-aperture based sun sensor based on a fast multi-point MEANSHIFT (FMMS) algorithm. [J] Sensors, 2011, 11(3): 2857-2874. SCI, IF=1.953； WOS:000288786900032, IDS: 740IT,citations:4,others:1,web of science:2, other web:0, SCI-E 35: Li Wengyang, Zhang Gaofei, You Zheng, Xing Fei (2012). Error compensation for area digital sun sensor. [J] Sensors, 12(9), 11798-11810； WOS:000309269900021,IDS: 012XL, citations:1,others:1,web of science:1, SCI-E 36: Zhong Xing, Jin Guang, Wang Dong, Xing Fei, Space Optics and Remote Sensing Technologies. [J] Opto-Electronic Engineering, 2011, 38(09): 1-5. 37: Xing Fei, You Zheng, Zhang Gaofei. Sun sensor based on the MEMS sunlight lead-in. [J] Journal of Functional Materials and Devices, 2008, 14(1): 246. EI 38: Dong Ying, Xing Fei, You Zheng. Brightness independent 4-star matching algorithm for lost-in-space 3-axis attitude acquisition. [J] Tsinghua Science &amp; Technology, 2006, 11(5): 543-548. Other web of science:1 39: Wei Minsong, Xing Fei*, Wang Geng，Zheng You，Multiplexing image detector based digital sun sensor for high precision and large field of view. [C] //9th ESA Round Table On Micro and Nano Technologies for Space Applications. 2014 40: Liu Fengdeng, Xing Fei*, Wu Yuelong, You Zheng, Process of super-black shading material applied to the star sensor based on Ni-P alloys. [C] //IPTA, International Conference on Optoelectronic Technology and Application 2014 41: Xing Fei *, et al. Study on the faint star extraction technology with MEMS gyro aided APS star tracker. [C]//ISPDI 2013-Fifth International Symposium on Photoelectronic Detection and Imaging. International Society for Optics and Photonics, 2013. EI； 42: Wang Hongjian, Xing Fei *, Fan Peiyong, Wang Chong, You zheng, A high-precision earth sensor with three separated FOVs for aircraft application. [C]//ISPDI 2013-Fifth International Symposium on Photoelectronic Detection and Imaging. International Society for Optics and Photonics, 2013. EI； 43: Wang Chong, Xing Fei *, Wang, Hongjian, You, Zheng. Optical flows method for lightweight agile remote sensor design and instrumentation. [C]//ISPDI 2013-Fifth International Symposium on Photoelectronic Detection and Imaging. International Society for Optics and Photonics, 2013. EI； 44: Xing Fei*, Wu yuelong, You zheng, A novel Method to Fabricate Ultra-Black Material with Micro/Nano structure for Star Tracker Baffle,[C]// 8th ESA Round Table On Micro and Nano Technologies for Space Applications. 2012 45: Xing Fei, You zheng, A novel MEMS based Sun sensor, [C]//7th ESA Round Table On Micro and Nano Technologies for Space Applications. 2010 46: Xing Fei*, You, Zheng, Micro aps cmos star tracker and its key techniques research, [C]// 60th International Astronautical Congress 2009, IAC 2009, v 6, p 4911-4915, 2009 EI 47: Xing Fei*，Dong Ying，You Zheng，APS star tracker and attitude estimation, [C]// First International Symposium on Systems and Control in Aerospace and Astronautics. 2006,Jan 19-21, Haerbin China EI; other citation: 5, web of science :2 48: Dong Ying, Xing Fei, You Zheng. An APS-based autonomous star tracker[C]//Photonics Asia 2004. International Society for Optics and Photonics, 2005: 225-233. 49: Dong Ying, Xing Fei, You Zheng. APS star sensor performance assessment through real-sky observation experiments[C]//Photonics Asia 2004. International Society for Optics and Photonics, 2005: 541-550.—- 50: Dong Ying, You Zheng, Xing Fei. Design of an APS based star tracker for microsatellite attitude determination[C]//55 th International Astronautical Congress. 2004. —- 51: 李进, 邢飞*, 王翀. 空间 CCD 相机高精度在轨调制传递函数估算[J]. 光学学报, 2015, 35(2): 211003. 52: 卫旻嵩，邢飞*，王赓，尤政，面向高精度太阳敏感器的探测器复用技术研究. [J]清华大学学报，2014, 54(10):pp1271-1275. 53: 李进, 邢飞*, 尤政. 基于 QC-LDPC 码的空间 CCD 图像 NAND 闪存存储纠错[J]. 光电子. 激光, 2014, 25(008): 1598-1605. 54: 孙婷, 邢飞*, 尤政. 高精度星敏感器光学系统误差分析. [J] 光学学报，2013, 33(3): 323003， EI； 55: 王翀，尤政，邢飞*，陶青长，大视场空间遥感相机的像速场及图像传感器曝光积分控制. [J] 光学学报， 2013，33（5）88-95， EI； 56: 卫旻嵩, 邢飞*, 李滨, 等. N形缝光线引入器太阳敏感器技术研究[J]. 宇航学报, 2013, 34(10): 1323-1329， EI； 57: 尤政, 王翀, 邢飞, 等. 空间遥感智能载荷及其关键技术[J]. 航天返回与遥感, 2013 (1): 35-43. 58: 孙婷, 邢飞*, 尤政. 一种基于天体运动学的星敏感器精度测量方法[J]. 清华大学学报: 自然科学版, 2012, 52(4): 430-435. EI； 59: 钟兴，金光，王栋，邢飞，CMOS星敏感器焦平面装配及标定. [J] 光电工程，2011, 第9期，pp1-5. 60: 邢飞, 尤政, 董瑛. 基干导航星域和 K 矢量的快速星图识别算法. [J] 宇航学报, 第31卷第10期宇航学V01.31 N010, 2010，EI; other citation 2; web of science 1; 61: 邢飞; 尤政; 张高飞. 基于MEMS光线引入器的太阳敏感器技术.[J] 功能材料与器件学报, 2008, 第14卷，第1期，246-250. EI 62: 邢飞，董瑛，武延鹏，尤政，星敏感器参数分析与自主校正. [J] 清华大学学报，2006年，Vol 45（11），1484-1488, EI 63: 邢飞，武延鹏，董瑛，尤政，微型星敏感器实验室测试系统研究. [J] 光学技术，2005年30（6）703-705，EI 64: 董瑛，邢飞，尤政，基于CMOS APS的星敏感器光学系统参数确定. [J] 宇航学报. 2004, 25(6): 663-668. EI 专利1: Zheng You, Fei Xing, Ting Sun, Method for Measuring Precision of Star Sensor and System Using the same. US2013/0013199 A1. Patent No.: US8,433,515 B2 2: Fei Xing, Zheng You, Ting Sun，Method for determining attitude of star sensor based on rolling shutter imaging, US2013/983,979 Patent No.: US9,503,653 B2 3: 卫旻嵩， 邢飞，尤政，太阳敏感器， ZL201410065241.4，授权公告日：2016-01-20 4: 邢飞，尤政，孙婷，基于卷帘曝光的星敏感器姿态确定方法，ZL201310053052.0，授权公告日：2015-06-24 5: 孙婷，邢飞，尤政，王晓初，星敏感器星图识别和姿态解算的快速鲁棒校验方法，CN 201610701536.5 6: 邢飞，王赓，尤政，太阳同步轨道卫星单视场星敏感器安装指向设计方法，ZL105 7: 邢飞，王赓，尤政，太阳同步轨道卫星双视场星敏感器安装指向设计方法，ZL 8: 邢飞，王赓，尤政，太阳同步轨道卫星三视场星敏感器安装指向设计方法， 9: 王赓，邢飞，卫旻嵩，尤政，高精度、大视场不同孔径太阳敏感器光线引入器设计方法， CN201510282773.8, 公开（公告）日 : 2015.08.19. 10: 卫旻嵩， 邢飞 ，尤政；无线自供电数字太阳敏感器，CN201510629603.2, 申请日 : 2015.09.28，公开日: 2015.11.25 11: 尤政，邢飞，王洪剑，李滨，樊佩荣，多视场分离的地球敏感器，ZL201310341671.X，授权日期：2015.10.28。 12: 邢飞，尤政，张高飞，孙剑，一种高精度APS太阳敏感器及其实现方法，ZL200910079564.8 13: 邢飞，尤政，张高飞，孙剑，一种多孔阵列式太阳敏感器的图像快速识别方法及装置，ZL200910080081.X，授权日期：2010.5.12 14: 尤政，邢飞，张高飞，李宇，一种太阳光入射角的计算方法及装置， ZL20091008017.2 授权日期：2010.9.15 15: 邢飞，尤政，张高飞，孙剑，一种太阳光入射角测量方法及装置， ZL200910088562.5，授权日期：2010.9.15 16: 尤政，邢飞，孙婷，张高飞，李滨，用于星敏感器的精度测量方法，ZL201110189264.2，授权日期：2012.8.22 17: 邢飞，尤政，孙婷，用于星敏感器的精度测量系统，ZL201110188262.1，授权日期：2012.7.18 18: 尤政，邢飞，董瑛，双视场星敏感器及利用其进行星图识别的方法，ZL200410091182.4，授权日期:2008.5.7 19: 邢飞，孙婷，尤政，星敏感器的三轴精度表述与测量方法，ZL201210059546.5，授权日期:2014.05.21 20: 邢飞, 孙婷, 尤政. 一种高精度星敏感器的精度测量方法: ZL201210167943.4，授权日期：2015.4.15 21: 尤政、邢飞、王洪剑、李滨、樊佩荣. 多视场分离的地球敏感器.ZL201310341671.X，授权日期：2013.10.28 22: 黎雯洋，张高飞，尤政，邢飞，一种面阵APS数字太阳敏感器的精度补偿方法，ZL2011102592096，授权日期：2013.10.16 23: 孙剑，尤政，李滨，张高飞，邢飞，一种三轴气浮台转动角度的测量装置，ZL2008102236634，授权日期：2010.06.02 24: 尤政，刘有军，李伟，邢飞，自供电无线模拟太阳角敏感器，ZL2009100812075，授权日期：2010.06.23 25: 赵璧如，邢飞，梁小芃，海波，地面增补转发器及无线数字广播同步得系统和方法，ZL2006101096990，授权日期，2011.12.07 26: 阮勇，尤政，李滨，张高飞，王晓峰，邢飞，一种框架式可变电容器及其制备方法，ZL2010101522975，授权日期，2011.09.14 27: 李滨，马林，邢飞，杨建中，尤政，微惯性测量装置，ZL201210240106X，授权日期：2014.10.22 28: 邢飞，海波，梁小芃，地面增补转泛起及无线数字广播同步的系统和方法，ZL2006101619353，授权日期：2012.05.23 29: 尤政，卫旻嵩，邢飞，李滨，一种数字太阳敏感器的误差修正方法及装置，ZL201010603535X，授权日期：2012.05.09","updated":"2018-02-09T12:34:56.000Z","categories":[{"name":"research","slug":"research","permalink":"http://yoursite.com/categories/research/"}],"tags":[{"name":"lab","slug":"lab","permalink":"http://yoursite.com/tags/lab/"},{"name":"sun sensor","slug":"sun-sensor","permalink":"http://yoursite.com/tags/sun-sensor/"},{"name":"star tracker","slug":"star-tracker","permalink":"http://yoursite.com/tags/star-tracker/"}]}]