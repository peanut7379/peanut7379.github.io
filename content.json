[{"title":"","date":"2018-01-20T16:00:00.000Z","path":"2018/01/21/index/","text":"","updated":"2018-01-21T15:15:13.000Z","categories":[],"tags":[]},{"title":"airflow前端到后台调用逻辑分析","date":"2017-06-27T16:00:00.000Z","path":"2017/06/28/airflow前端到后台调用逻辑分析/","text":"传参方式分析：使用docker镜像：puckel/docker-airflow 下载镜像：1$ docker pull puckel/docker-airflow 启动：12$ docker run -d -p 8080:8080 puckel/docker-airflow（-d 以后台模式启动，-p 端口映射 主机端口：容器端口） 进入docker：1docker exec -it [container_name] bash 接下来以分析tutorial为例：分析run按钮：点击的script代码如下：这个函数首先组装一个url地址，然后window.location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。12345Id选择器： 以“#”来定义class选择器：以“.”来定义hasClass() 方法检查被选元素是否包含指定的 class，返回true或falseencodeURIComponent() 函数可把字符串作为 URI 组件进行编码，该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * &apos; ( ) ，该函数假定它的参数是 URI 的一部分，因此 encodeURIComponent() 函数将转义用于分隔 URI 各个部分的标点符号。 组装格式如下：1/admin/airflow/run?task_id= &amp;dag_id=&amp;ignore_all_deps &amp;ignore_task_deps= &amp;ignore_ti_state= &amp;execution_date= &amp;origin= 可以通过在web调试窗设断点来找出最终组合的字符串如下形式：123&quot;/admin/airflow/run?task_id=sleep&amp;dag_id=tutorial&amp;ignore_all_deps=false&amp;ignore_task_deps=false&amp;ignore_ti_state=false&amp;execution_date=2017-05-25&amp;origin=http%3A%2F%2F127.0.0.1%3A8080%2Fadmin%2Fairflow%2Fgraph%3Fdag_id%3Dtutorial&quot;&quot;/admin/airflow/success?task_id=templated&amp;dag_id=tutorial&amp;upstream=false&amp;downstream=false&amp;future=false&amp;past=true&amp;execution_date=2017-05-25&amp;origin=http%3A%2F%2F127.0.0.1%3A8080%2Fadmin%2Fairflow%2Fgraph%3Fdag_id%3Dtutorial&quot; 这里我们就找到了airflow前端到后台调用的方式（通过url传参），接下来需要找出如何通过url传参到后台响应： url传参分析：先贴最终结果，airflow使用的是python的flask框架，定义的文件在如下路径的python文件里，从下图中我们可以看到暴露了/run路径，同样的还有success也是以这种方式暴露的1/usr/local/lib/python2.7/dist-packages/airflow/www/views.py 至于如何找到用什么框架方法，是先通过组装好的url的特征字符串比如“run”，然后使用grep命令进行文件内容查找，锁定到views.py文件，然后查看import的库找到所使用的框架，之后我们就可以通过学习框架继续深入研究airflow啦！这是我目前使用的分析逻辑，虽然笨了点，希望对大家能有所帮助，以此抛砖引玉，以后学习更深入了了解的框架更多了，应该能根据经验判断出套用的框架或者调用方式，希望大家有更好的方法能与笔者交流~","updated":"2018-01-21T15:15:56.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"airflow","slug":"airflow","permalink":"http://yoursite.com/tags/airflow/"}]},{"title":"shell常用命令笔记","date":"2017-05-28T16:00:00.000Z","path":"2017/05/29/shell常用命令笔记/","text":"通过 uname -r 命令查看你当前的内核版本:12$ uname -r3.10.0-327.el7.x86_64 vi使用:12345670 移至行首$ 移至行尾u 撤销dd 删除光标所在行u 撤销上一步操作X 向后删除字符x 向前删除字符 运行脚本两种方式：121、source scriptname //这种方式就像直接输入一样2、./scriptname //这种方式脚本运行在子shell find命令：1234567891011121314一般形式为:find pathname -options [-print -exec -ok]例：-name选项：$ find ~ -name &quot;*.txt&quot; -print$ find . -name &quot;[A-Z]*&quot; -print //当前目录及子目录中查找以大写字母开头$ find . -name &quot;[a-z][a-z][0--9][0--9].txt&quot; -print //在当前目录查找文件名以两个小写字母开头,跟着是两个数字,最后是 *.txt的文件$ find /etc -type d -print //-type查找所有的文件夹b - 块设备文件。d - 目录。c - 字符设备文件。p - 管道文件。l - 符号链接文件。f - 普通文件。 grep命令：123456789101112131415161718一般格式为:grep [选项] 基本正则表达式 [文件] //基本正则表达式可为字符串。常用的grep选项有:-c 只输出匹配行的计数，匹配的有几行-i 不区分大小写(只适用于单字符)。-h 查询多文件时不显示文件名。-l 查询多文件时只输出包含匹配字符的文件名。 -n 显示匹配行及行号。-s 不显示不存在或无匹配文本的错误信息。-v 显示不包含匹配文本的所有行例子：$ grep “sort&quot; *.doc$ grep “string&lt;tab&gt;” * //&lt;Tab&gt;表示点击 tab键$ grep ’48[346]’ * //使用 []来指定字符串范围,这里用48开始,以3或4或6结尾$ grep ‘[A-Z][B-Z]..C’ * //匹配头两个是大写字母，以C结尾，中间两位任意 awk命令：1234567动作用&#123;&#125;括起来，if后面的条件用（）括起来awk执行时,其浏览域标记为 $1,$2...$n。这种方法称为域标识。使用$1,$3表示参照第1和第3域，可使用 $0,意即所有域例子：$ awk ‘&#123;print $0&#125;’ grade.txt &gt;test //重定向输出到文件test，此时不显示$ awk ‘&#123;print $0&#125;’ grade.txt | tee test //重定向输出到文件test，并显示到屏幕匹配：使用~紧跟正则表达式$ docker ps -a | awk &apos;&#123;if($2~/p/) print $1&#125;’ // 通过管道找到docker ps -a命令输出中匹配第二列包含p的，然后输出第一列 1234$ awk ‘&#123;if($4~/brown/) print $0&#125;’ grade.txt //匹配第四列包含字符串brown的，然后打印匹配记录行精确匹配用==$ awk &apos;$3==“brown” &#123;print $0&#125;’ grade.txt$ awk ‘&#123;if($4 !~/brown/) print $0&#125;’ grade.txt //不匹配第四列包含字符串brown的，然后打印匹配记录行 sort命令：123456sort -c filename //检查文件是否已分类sort -t: filename //以第1域进行分类(默认)，域分隔符为“:”，默认为空格sort -t: -r filename //-r逆序分类sort -u filename //去除重复行sort -t: -k2 filename //以第2域进行分类sort -k2 -k4 filename //先以第4域,再以第1域分类 ls命令：12ll等价于 ls -l输出文件大小以B为单位 iptables查看及修改防火墙规则：查看规则:123456$ sudo iptables -nL --line-number-L 查看当前表的所有规则，默认查看的是filter表，如果要查看NAT表，可以加上-t NAT参数-n 不对ip地址进行反查，加上这个参数显示速度会快很多-v 输出详细信息，包含通过该规则的数据包数量，总字节数及相应的网络接口–line-number 显示规则的序列号，这个参数在删除或修改规则时会用到 -R参数修改规则:12sudo iptables -R INPUT 5 -j ACCEPTsudo iptables -R FORWARD 1 -j ACCEPT","updated":"2017-01-20T16:00:00.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Mac使用","date":"2017-05-21T16:00:00.000Z","path":"2017/05/22/Mac使用/","text":"关闭端口占用方法：查询PID:1lsof -i:端口号 关闭：kill -9 PID","updated":"2018-01-21T15:12:00.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"Mac使用","slug":"Mac使用","permalink":"http://yoursite.com/tags/Mac使用/"}]},{"title":"VPS调研","date":"2017-05-15T16:00:00.000Z","path":"2017/05/16/VPS调研/","text":"比较：1、 http://blog.csdn.net/zhang_zp2014/article/details/468222632、搬瓦工与vultr及linode三家VPS服务商http://www.bawagon.com/bandwagonvultrlinode/首先价格上搬瓦工实惠，搬瓦工是Openvz系统的VPS，而Vultr及Linode都是KVM系统，性能上比搬瓦工要更好，可操作性更好。因此追求性能的选择Vultr及Linode ,追求价格的可以选择搬瓦工VPS。 Xen、OpenVZ、KVM三大VPS技术优劣势详解基于KVM系统好，能保证内存http://vps.zzidc.com/vpsjishu/452.html VPS服务器全面性能测试：https://www.freehao123.com/vps-cpu-io-unixbench/ VPS主机的CPU详细参数:$ cat /proc/cpuinfo查看内存信息：cat /proc/meminfo测试硬盘读写速度：sudo dd if=/dev/zero of=test bs=1M count=1024 172.104.111.103172.104.111.103ssserver -p 8383 -k 201702 -m rc4-md5 -d start","updated":"2018-01-21T15:11:38.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"vps","slug":"vps","permalink":"http://yoursite.com/tags/vps/"}]},{"title":"Nginx发布网站","date":"2017-04-29T16:00:00.000Z","path":"2017/04/30/Nginx发布网站/","text":"修改配置原理：/etc/nginx/nginx.conf配置文件里的 http 配置区块里，用了一个 include 指令，把所有的在 /etc/nginx/conf.d 这个目录下面的 .conf 文件包含到了这里。include /etc/nginx/conf.d/*.conf;我们如果想去添加自己的配置，可以在/etc/nginx/conf.d 这个目录下新建一个以 .conf 结尾的文件，重新加载 nginx 以后，这些配置就会生效了。 修改/etc/nginx/conf.d下default.conf配置文件123456789server &#123; listen 80 default_server; #监听80端口 server_name wuzhigang.com www.wuzhigang.com; #定义访问的域名 location / &#123; root /home/lijingdong/web; #网站的根目录位置 index 首页.html; #定义首页索引文件名称 &#125;&#125; 保存之后，sudo nginx -t测试配置文件语法是否正确，返回：12nginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful 然后service nginx reload重新加载nginx配置好default.conf文件后,打开网址，显示403forbidden，是由于权限问题，修改nginx.conf文件下第一行为user root;即可","updated":"2018-01-21T15:11:55.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"Javascript笔记","date":"2017-04-15T16:00:00.000Z","path":"2017/04/16/Javascript笔记/","text":"外部调用:1&lt;script src=\"myScript.js\"&gt;&lt;/script&gt; myScript.js 文件代码如下：1function myFunction()&#123; document.getElementById(\"demo\").innerHTML=\"我的第一个 JavaScript 函数\"; &#125; 注：外部脚本不包含&lt;script&gt; 标签 输出：（4种方式）1、 window.alert() 弹出警告框123&lt;script&gt;window.alert(5 + 6);&lt;/script&gt; 2、 document.write() 方法将内容写到 HTML 文档中123&lt;script&gt;document.write(\"&lt;h1&gt;这是一个标题&lt;/h1&gt;\");&lt;/script&gt; 如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖 3、使用 innerHTML 写入到 HTML 元素1document.getElementById(\"demo\").innerHTML=\"My First JavaScript\"; 4、使用 console.log() 写入到浏览器的控制台1console.log(“string\"); 定义变量:var name=&quot;Gates&quot;, age=56, job=&quot;CEO&quot;;如果重新声明 JavaScript 变量，该变量的值不会丢失： 对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔：var person={firstname:&quot;Bill&quot;, lastname:&quot;Gates&quot;, id:5566};对象属性有两种寻址方式：12name=person.lastname;name=person[\"lastname\"]; &lt;button type=&quot;button&quot; onclick=&quot;alert(&#39;欢迎!&#39;)&quot;&gt;点我!&lt;/button&gt; 使用 String 对象的 toUpperCase() 方法来把文本转换为大写： 您会经常看到 document.getElementById(“some id”)。这个方法是 HTML DOM 中定义的。DOM (Document Object Model)（文档对象模型）是用于访问 HTML 元素的正式 W3C 标准。1234567&lt;script&gt;function changeImage()&#123;&#125;&lt;/script&gt;&lt;img id=\"myimage\" onclick=\"changeImage()\"src=\"/images/pic_bulboff.gif\" width=\"100\" height=\"180\"&gt; 改变 HTML 元素的样式:x=document.getElementById(&quot;demo&quot;) // 找到元素x.style.color=&quot;#ff0000&quot;; // 改变样式 获取输入框内容：12&lt;input id=\"demo\" type=\"text”&gt; //输入框创建var x=document.getElementById(\"demo\").value; 注释：123//单行/*多行*/ JavaScript 对大小写是敏感的 对代码行进行折行：您可以在文本字符串中使用反斜杠对代码行进行换行。下面的例子会正确地显示：document.write(&quot;你好 \\世界!&quot;);不过，您不能像这样折行：document.write \\(&quot;你好世界!&quot;); 常见的HTML事件的列表: 事件 描述 onchange HTML 元素改变 onclick 用户点击 HTML 元素 onmouseover 用户在一个HTML元素上移动鼠标 onmouseout 用户从一个HTML元素上移开鼠标 onkeydown 用户按下键盘按键 onload 浏览器已完成页面的加载 基于某些条件对变量进行赋值:variablename=(condition)?value1:value2例如：123456789101112voteable=(age&lt;18)?\"年龄太小\":\"年龄已达到\";time 当前24小时制整点数字 例如2 15if (condition1)&#123;&#125;else if (condition2)&#123;&#125;else&#123;&#125; 改变HTML内容：123456789通过id查找 HTML 元素:var x=document.getElementById(\"main\");通过标签名查找 HTML 元素:var x=document.getElementById(\"main\");var y=x.getElementsByTagName(\"p\");通过类名查找 HTML 元素:x=document.getElementsByClassName(\"intro\"); 改变HTML属性：1document.getElementById(id).属性标签=新属性值 改变HTML样式：123document.getElementById(id).style.property=新样式例如：document.getElementById(\"p2\").style.color=\"blue\";","updated":"2017-05-25T16:00:00.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"html+css笔记","date":"2017-04-15T16:00:00.000Z","path":"2017/04/16/html+css笔记/","text":"Html:&lt;b&gt;加粗&lt;p&gt;段落 method 属性:表单数据可以作为 URL 变量（method=”get”）或者 HTTP post （method=”post”）的方式来发送。 浏览器使用 method 属性设置的方法将表单中的数据传送给服务器进行处理。共有两种方法：POST 方法和 GET 方法。 如果采用 POST 方法，浏览器将会按照下面两步来发送数据。首先，浏览器将与 action 属性中指定的表单处理服务器建立联系，一旦建立连接之后，浏览器就会按分段传输的方法将数据发送给服务器。 在服务器端，一旦 POST 样式的应用程序开始执行时，就应该从一个标志位置读取参数，而一旦读到参数，在应用程序能够使用这些表单值以前，必须对这些参数进行解码。用户特定的服务器会明确指定应用程序应该如何接受这些参数。 另一种情况是采用 GET 方法，这时浏览器会与表单处理服务器建立连接，然后直接在一个传输步骤中发送所有的表单数据：浏览器会将数据直接附在表单的 action URL 之后。这两者之间用问号进行分隔。 JSON语法规则: 数据为键/值对 数据由逗号隔开 大括号保存对象 方括号保存数组 函数 描述 JSON.parse() 将JSON字符串转为js对象 JSON.stringify() 将js值转为JSON字符串 代码规范:代码一行太长，建议在 运算符 或 逗号后换行 变量声明时如果不使用var关键字，即使在函数内定义，也是全局变量。 CSS:语法格式：selector {declaration；declaration；}declaration格式属性：[attribute=value] （注意：中间不要留有空格）Id选择器： 以#来定义class选择器：以.来定义 三种颜色定义方式： 十六进制 #ff0000 RGB rgb(255,0,0) 颜色名称 redCSS参考手册","updated":"2017-05-25T16:00:00.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"docker学习整理","date":"2017-04-14T16:00:00.000Z","path":"2017/04/15/dockerStudy/","text":"1docker version：查看docker的版本号，包括客户端、服务端、依赖的Go等 1docker info ：查看系统(docker)层面信息，包括管理的images, containers数等 查找镜像，可做模糊搜索1docker search &lt;image&gt;：在docker index中搜索image 下载镜像1docker pull &lt;image&gt; ：从docker registry server 中下拉image 查看镜像12docker images： 列出imagesdocker images -a ：列出所有的images（包含历史） 删除镜像或容器：1234docker rmi &lt;image ID&gt;： 删除一个或多个imagedocker rm &lt;container ID&gt;： 删除一个或多个containerdocker rm `docker ps -a -q` ：删除所有的containerdocker ps -a -q | xargs docker rm ：同上, 删除所有的container 使用镜像创建容器12345678docker run [options] [image]options:-d 以后台方式运行-p 指定端口映射 -p &lt;host_port:contain_port&gt;docker run -d -p 8080:8080 puckel/docker-airflow-i -t 一般同时使用，在新容器内指定一个伪终端或终端，并允许进行交互docker run -i -t centos:6.9 /bin/bash :使用镜像centos:6.9创建container并进入交互模式, login shell是/bin/bash 查看容器:1234docker ps ：列出当前所有正在运行的containerdocker ps -l ：列出最近一次启动的containerdocker ps -a ：列出所有的container（包含历史，即运行过的container）docker ps -q ：列出最近一次运行的container ID 开启/停止/重启/连接container:12docker start/stop/restart &lt;container&gt; :注：使用start是启动已经创建过得container，使用run则通过image开启一个新的container。docker attach [container_id] ：连接一个正在运行的container实例（即实例必须为start状态，可以多个窗口同时attach一个container实例） 通过容器生成新的镜像1docker commit &lt;container&gt; [repo:tag] 将一个container固化为一个新的image，后面的repo:tag可选。 容器备份、恢复和迁移：docker的备份方式有export和save两种。export备份：1234export是当前的状态，针对的是容器，docker save 是针对镜像images。 $ docker export [CONTAINER ID] &gt;export.tar //export是把容器打成一个tar包。import恢复： $ cat export.tar | docker import - repo:tag save备份： 12345 $ docker save repo:tag &gt;save.tar恢复镜像: $ docker load &lt;save.tar对image打tag$ docker tag imageID repo:tag 两者的区别: 导出后再导入(exported-imported)的镜像会丢失所有的历史，而保存后再加载（saveed-loaded）的镜像没有丢失历史和层 (layer)。这意味着使用导出后再导入的方式，你将无法回滚到之前的层(layer)，同时，使用保存后再加载的方式持久化整个镜像，就可以做到层回滚（可以执行docker tag 来回滚之前的层）。","updated":"2018-01-21T15:11:26.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"docker下centos6.9镜像安装jira及破解完整操作记录","date":"2017-04-13T16:00:00.000Z","path":"2017/04/14/docker下centos6.9镜像安装jira及破解完整操作记录/","text":"说明：以下操作命令中以$开头的是在主机终端下操作的，以#开头的是在容器交互终端下操作的，即docker镜像系统centos6.9，所需文件在这里,下文中拷贝命令的时候注意使用mkdir命令建立相对应的文件夹~1.下载docker mac版2.在https://hub.docker.com/explore/上查找镜像， 也可以使用 docker search 命令来搜索镜像。 docker search ：在docker index中搜索image,例如1$ docker search centos 红色箭头显示为官方版本 我们选择官方版本，但是可以通过选择版本标签来匹配安装版本，例如： docker pull centos:5.11 or docker pull centos:6.6 3.下载cantos6.9版本的镜像1$ docker pull centos:6.9 之后打开进入容器：1$ docker run -i -t centos:6.9 /bin/bash -t:在新容器内指定一个伪终端或终端。-i:允许你对容器内的标准输入 (STDIN) 进行交互。 查看系统版本 1# cat /etc/redhat-release 4.安装mysql1# yum install -y mysql-server mysql -y代表自动选择y 5.安装完成以后启动mysql1# /etc/init.d/mysqld start 6.验证安装成功1mysql&gt; show databases; 7.安装jdk1$ mkdir java 8.mac主机中查看docker容器ID：1$ docker ps 使用cp命令把主机的文件拷贝到docker容器：格式：1$ docker cp /Users/peanut/Documents/Data\\ Study/jdk-8u121-linux-x64.tar containerID:/home/java/jdk-8u121-linux-x64.tar 9.容器交互终端下解压：1# tar -xvf jdk-8u121-linux-x64.tar 配置环境：1# vi /etc/profile 文件最后添加以下内容：1234JAVA_HOME=/home/java/jdk1.8.0_121CLASSPATH=$JAVA_HOME/lib:$JAVA_HOME/jre/libPATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/binexport PATH CLASSPATH JAVA_HOME 这样JDK就设置好了，然后以下命令使其生效：12# source /etc/profile# echo $JAVA_HOME 验证java的路径 10.拷贝jira安装包到容器1$ docker cp /Users/peanut/Documents/Data\\ Study/atlassian-jira-6.3.6.tar containerID:/home/jira/atlassian-jira-6.3.6.tar 解压1# tar -xvf atlassian-jira-6.3.6.tar jira的8005和8080端口都重新修改一下，在server.xml中，我的修改为8007和8099了，修改方法如下:1#vi jira/atlassian-jira-6.3.6-standalone/conf/server.xml 在其中找到8005和8080进行修改接着在atlassian-jira-6.3.6-standalone文件同目录下创建一个文件夹：jira_home，修改配置文件 1# vi /home/jira/atlassian-jira-6.3.6-standalone/atlassian-jira/WEB-INF/classes/jira-application.properties 修改为如下内容：1jira.home = /home/jira/jira_home 启动jira服务： 1# /home/jira/atlassian-jira-6.3.6-standalone/bin/start-jira.sh 11.1# mysql -u root -p 默认无密码创建数据库jiradb：1mysql&gt; create database jiradb character set gbk; 创建用户并赋予权限：12345mysql&gt; create user jirauser identified by &apos;password&apos;;&gt; GRANT ALL ON jiradb.* TO &apos;jirauser&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos; with grant option;&gt; flush privileges; 12.在JIRA的数据目录下删除文件：dbconfig.xml,删除这个文件再重启jira后就可以重新看到初始配置界面，这里可不执行这一步~1# rm -f /home/lijingdong/jira/jira_home/dbconfig.xml 13.重新启动JIRA服务启动：1# /home/jira/atlassian-jira-6.3.6-standalone/bin/start-jira.sh 停止：1# /home/jira/atlassian-jira-6.3.6-standalone/bin/shutdown.sh 14.记下容器ID,然后1$ exit 退出容器 15.docker commit 命令创建新镜像：1$ docker commit containerID centos6/jira:1.0 注意，如果不commit创建新镜像，之前的修改就都没了！1$ docker images查看新创建的镜像： 16.重启镜像，并将端口8099映射到主机的8099端口：1$ docker run -i -t -p 8099:8099 centos6/jira:1.0 /bin/bash 此时需重新启动mysql，重新source JAVA_HOME，重新启动jira：123# /etc/init.d/mysqld start# source /etc/profile# /home/jira/atlassian-jira-6.3.6-standalone/bin/start-jira.sh 然后打开0.0.0.0:8099即可看到jira 17.jira破解:将atlassian-universal-plugin-manager-plugin-2.17.13.jar复制到容器上/home/jira/atlassian-jira-6.3.6-standalone/atlassian-jira/WEB- INF/atlassian-bundled-plugins/下： 12$ docker cp /Users/peanut/Documents/Data\\ Study/atlassian-universal-plugin-manager-plugin-2.17.13.jar containerID:/home/jira/atlassian-jira- 6.3.6-standalone/atlassian-jira/WEB-INF/atlassian-bundled-plugins/ 将破解文件atlassian-extras-2.2.2.jar复制到容器上/home/lijingdong/jira/atlassian-jira-6.3.6-standalone/atlassian-jira/WEB-INF/lib/目录下替换同名文件:12$ docker cp /Users/peanut/Documents/Data\\ Study/atlassian-extras-2.2.2.jar containerID:/home/jira/atlassian-jira-6.3.6-standalone/atlassian- jira/WEB-INF/lib 之后重启jira。点击右上角齿轮形状的管理图标，选择“系统”，再选择“授权”，看到使用日期不到1个月，如下所示：填写授权码，授权码参数范例如下：123456789101112131415Description=JIRA: Commercial,CreationDate=你的安装日期，格式（yyyy-mm-dd）,jira.LicenseEdition=ENTERPRISE,Evaluation=false,jira.LicenseTypeName=COMMERCIAL,jira.active=true,licenseVersion=2,MaintenanceExpiryDate=你想设置的失效日期如：2099-12-31,Organisation=joiandjoin,SEN=你申请到的SEN注意没有前缀LID,ServerID=你申请到的ServerID,jira.NumberOfUsers=-1,LicenseID=LID你申请到的SEN，注意LID前缀不要丢掉,LicenseExpiryDate=你想设置的失效日期如：2099-12-31,PurchaseDate=你的安装日期，格式（yyyy-mm-dd） 破解完成:18.docker容器跨服务器迁移： 有两种方法，我们使用save方式:备份：1$ docker save centos6/jira:2.0 &gt;centos6_jira.tar 使用scp命令将文件拷贝到远程服务器上：1$ scp /Users/peanut/Documents/Data\\ Study/centos6_jira.tar user@serverIP:/home/user 恢复： 1$ docker load &lt;centos6_jira.tar 查看恢复的镜像： 1$ docker images","updated":"2018-01-21T15:11:32.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"},{"name":"jira","slug":"jira","permalink":"http://yoursite.com/tags/jira/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"丑奴儿·书博山道中壁","date":"2017-03-31T09:02:23.000Z","path":"2017/03/31/丑奴儿/","text":"少年不识愁滋味，爱上层楼。爱上层楼，为赋新词强说愁。而今识尽愁滋味，欲说还休。欲说还休，却道天凉好个秋。","updated":"2018-01-21T15:10:45.000Z","categories":[{"name":"think","slug":"think","permalink":"http://yoursite.com/categories/think/"}],"tags":[]},{"title":"西洲曲","date":"2017-03-31T09:01:12.000Z","path":"2017/03/31/西洲曲/","text":"忆梅下西洲，折梅寄江北。单衫杏子红，双鬓鸦雏色。西洲在何处？两桨桥头渡。日暮伯劳飞，风吹乌臼树。树下即门前，门中露翠钿。开门郎不至，出门采红莲。采莲南塘秋，莲花过人头。低头弄莲子，莲子清如水。置莲怀袖中，莲心彻底红。忆郎郎不至，仰首望飞鸿。鸿飞满西洲，望郎上青楼。楼高望不见，尽日栏杆头。栏杆十二曲，垂手明如玉。卷帘天自高，海水摇空绿。海水梦悠悠，君愁我亦愁。南风知我意，吹梦到西洲。","updated":"2018-01-21T15:10:11.000Z","categories":[{"name":"think","slug":"think","permalink":"http://yoursite.com/categories/think/"}],"tags":[]},{"title":"git个人博客使用","date":"2017-03-25T16:00:00.000Z","path":"2017/03/26/git个人博客使用/","text":"步骤： 在source文件夹相应分类目录下写.md文件 在每个分类目录下将索引按格式要求写入index.md文件 根目录下执行命令1$ hexo g -d markdown语法参考链接123---title: *******--- 抬头部分还支持的其他参数： markdown支持html语法加颜色（类似于html的语法）：1&lt;font color=#ff0000&gt;内容部分&lt;/font&gt; 修改字体：12&lt;font face=\"手札体-简\"&gt;内容部分&lt;/font&gt; 添加图片：12![](/img/airflow/run.png)这里的根路径是指source文件夹 添加超链接123[文字](http://********)例：[CSS参考手册](http://www.w3school.com.cn/cssref/css_selectors.asp)","updated":"2018-01-20T16:00:00.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}]},{"title":"w3m文字浏览器基本操作","date":"2017-03-17T16:00:00.000Z","path":"2017/03/18/w3m文字浏览器基本操作/","text":"安装：1$ yum install w3m 以网址启动w3m：1$ w3m www.baidu.com 这时打开网页，且处于交互模式下，可输入命令进行操作： 基本操作：1234567891011121314151617181920H 显示帮助信息j,k,h,l(或上下左右方向键) 移动光标space 向下翻页b 向上翻页&lt;,&gt; 用来左右滚屏tab 移动到下一个超链接T 新建标签页，和当前页面相同，相当于复制B 返回前一个页面，后退U 重新输入需要打开的网址ctrl+t 在新标签页打开光标所在超链接&#123;，&#125; 在标签页间左右切换/ 向后查找当前页面？ 向前查找当前页面n 查找下一个已查找过的关键字N 向前查找已查找过的关键字m 切换鼠标控制方式ctrl+q 关闭当前标签页q 退出w3m浏览器搜索： 在需要输入的文本框内按回车enter，下面就会出现TEXT: ，这时你可以输入你要搜索的文字。再按回车就是返回给文本框。这时再把光标移到”百度搜索”的那个按键，回车，就可以开始搜索了！","updated":"2018-01-21T15:05:23.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"w3m","slug":"w3m","permalink":"http://yoursite.com/tags/w3m/"}]},{"title":"bash命令行处理步骤及源码解析","date":"2017-03-15T16:00:00.000Z","path":"2017/03/16/bash命令行处理步骤及源码解析/","text":"之前在执行脚本时发现一个问题： 12345$ cat a.sh#!/bin/bashOPTS=&quot;--conf javaOption=\\&quot;-Da=b -Dc=d\\&quot;&quot;eval ./c.sh $OPTS./c.sh $OPTS 1234567$ cat c.sh#!/bin/bashn=$#for ((i=0; i&lt;n; i++));do echo &quot;$i:&#123;&quot;$1&quot;&#125;&quot; shiftdone 对于加eval和不加eval处理的./c.sh $OPTS命令结果是不一样的，而且直接的./c.sh $OPTS得出的并不是我们想要的结果:123456789一、eval ./c.sh $OPTS结果：0:&#123;--conf&#125;1:&#123;javaOption=-Da=b -Dc=d&#125;二、./c.sh $OPTS结果：0:&#123;--conf&#125;1:&#123;javaOption=&quot;-Da=b&#125;2:&#123;-Dc=d&quot;&#125; 为了说明这个问题，我研究了一下bash命令行处理的流程，为什么会出现这种差别，以下分为两步来说明：（1）说明bash命令行处理流程；（2）使用grep命令+log打印+gdb+xcode来重新调试源码，从源码里解释流程。在这里贴出官方源码下载地址，此处我使用的版本是bash4.4 首先来说一下bash命令行处理流程，分为12步，来自《学习bash》这本书中，流程图如下：对于一行bash命令的执行流程分为两大步骤：解析和执行。 解析的作用是获得用于执行的命令结构体：COMMAND *global_command执行主要是针对特定类型的命令进行执行和结果处理，我们主要看解析过程。 解析bash的入口函数main()位于文件shell.c中12345678910111213141516intmain (argc, argv, env) int argc; char **argv, **env;&#123; .... shell_initialize (); .... run_startup_files (); .... shell_initialized = 1; /* Read commands until exit condition. */ reader_loop (); exit_shell (last_command_exit_value);&#125; main函数前部分主要做初始化工作，初始化完成之后，进入eval.c中的交互循环函数reader_loop()（shell.c中799行）。该函数不断读取和执行命令，直到遇到EOF。此时函数调用关系为：main()–&gt;reader_loop()。 123456789101112131415161718/* Read and execute commands until EOF is reached. This assumes that the input source has already been initialized. */intreader_loop ()&#123; .... if (read_command () == 0) &#123; .... &#125; else if (current_command = global_command) &#123; .... execute_command (current_command); &#125; .... return (last_command_exit_value);&#125; reader_loop()函数中调用read_command()取得命令结构体global_command，然后赋值给current_command并交给execute_command ()去执行。 read_command ()调用parse_command ()，此时函数调用关系为：main()–&gt;reader_loop()–&gt;read_command()–&gt;parse_command() 123456789101112131415161718192021222324252627/* Read and parse a command, returning the status of the parse. The command is left in the globval variable GLOBAL_COMMAND for use by reader_loop. This is where the shell timeout code is executed. */intread_command ()&#123; .... result = parse_command (); .... return (result);&#125;..../* Call the YACC-generated parser and return the status of the parse. Input is read from the current input stream (bash_input). yyparse leaves the parsed command in the global variable GLOBAL_COMMAND. This is where PROMPT_COMMAND is executed. */intparse_command ()&#123; .... r = yyparse (); if (need_here_doc) gather_here_documents (); return (r);&#125; parse_command()调用y.tab.c中的yyparse ()函数，并使用函数gather_here_documents ()处理here document类型的输入重定向。 yyparse ()由YACC通过parse.y生成，函数内使用大量的goto语句，可读性较差： 12345678910111213141516171819202122232425262728293031323334intyyparse ()&#123; .... yychar = YYLEX; .... yytoken = YYTRANSLATE (yychar); .... yyn += yytoken; .... switch (yyn) &#123; case 2: &#123; global_command = (yyvsp[(1) - (2)].command); .... &#125; break; case 3: &#123; global_command = (COMMAND *)NULL; .... &#125; break; .... case 6: &#123; (yyval.word_list) = make_word_list ((yyvsp[(1) - (1)].word), (WORD_LIST *)NULL); &#125; break; .... default: break; &#125; .... return YYID (yyresult);&#125; 函数内调用yylex()(宏定义：#define YYLEX yylex ())来获得并计算出整型变量yyn的值，然后根据不同的yyn值获取具体的命令结构体。 在函数yylex()内部，调用read_token()获得各种类型的token并进一步调用read_token_word()获取具体的不同类型的单词结构WORD_DESC。 之后在yyparse()中，调用文件make_cmd.c中各种函数，根据yylex()获得的各种token和word组装成具体command。 此时的函数调用关系为： main()–&gt;reader_loop()–&gt;read_command()–&gt;parse_command()–&gt;yyparse()–&gt;yylex()–&gt;read_token()——&gt;read_token_word()————&gt;global_command 下边来举个例子例1，这是我在下载的bash源码中添加了printf编译后的一个简单命令执行的输出，其中的每个名词都是源码里的函数名，如果需要找到所在文件，我们可以使用grep命令，例如grep -n “reader_loop” *(其中-n代表标出所在行数，*代表在该文件夹下的所有文件中查找,更详细的grep用法大家可以查看linux shell编程指南)：12345678910111213141516171819202122232425262728293031323334353637$ cat test1.sh./c.sh --conf javaOption=\"-Da=b -Dc=d\"$ ../bash-4.4/bash test1.shreader_loopread_commandparse_commandyyparseStarting parse[Function]read_tokenreserved_word_acceptableCHECK_FOR_RESERVED_WORDreserved_word_acceptablereserved_word_acceptable[Function]read_tokenreserved_word_acceptableCHECK_FOR_RESERVED_WORDreserved_word_acceptablereserved_word_acceptable[Function]read_tokenreserved_word_acceptableCHECK_FOR_RESERVED_WORDreserved_word_acceptablereserved_word_acceptable[Function]read_tokenexpand_wordsbrace_expansion //大括号扩展shell_expand_word_list //5-8步string_extract_double_quoted //双引号处理-Da=b -Dc=ddequote_string-Da=b -Dc=dquote_stringdequote_stringdequote_stringdequote_string0:&#123;--conf&#125;1:&#123;javaOption=-Da=b -Dc=d&#125; 上边的输出基本对应12步处理流程，接下来我们具体深入分析： 首先看两个执行结果： 脚本内容：12OPTS=&quot;--conf javaOption=\\&quot;-Da=b -Dc=d\\&quot;&quot;./c.sh $OPTS 执行结果如下：1230:&#123;--conf&#125;1:&#123;javaOption=&quot;-Da=b&#125;2:&#123;-Dc=d&quot;&#125; 脚本内容： 1./c.sh --conf javaOption=&quot;-Da=b -Dc=d&quot; 执行结果如下： 120:&#123;--conf&#125;1:&#123;javaOption=-Da=b -Dc=d&#125; 这里第一个脚本未对双引号进行处理，为什么呢？出现这种不同，主要是在于命令行处理流程中对于双引号的处理位置。在命令行处理流程中,位于subst.c文件9017（大约位置，因为加log信息后有变）处的函数 expand_word_internal()是处理从第五步波浪号扩展到第八步算术替换的核心函数，而实际对于双引号的处理是在与这几步变换并列的一个switch语句里，bash在处理完$相关的扩展之后会直接跳出switch，所以就跳过了关于双引号的处理，也就是说switch语句里case的顺序是$符号的相关扩展在前，双引号处理的在后。至于我是如何找到的呢，在这里也贴出来供大家参考，少走弯路：在例1中我们可以看到根据log信息我们已经发现了双引号处理的函数是string_extract_double_quoted，那么我们接下来要做的就是找到string_extract_double_quoted()函数是如何从read_loop()函数一路被调用的，所以现在我们使用gdb,调试命令如下：(当前我们在bash-4.4文件夹下，a.sh相对路径bash-4.4/task/a.sh)1234567891011121314151617181920212223242526272829[task]$ cat a.sh#!/bin/bash./task/c.sh --conf javaOption=\"-Da=b -Dc=d\"[task]$ cd ..[bash-4.4]$ gdb bash//此时进入到gdb调试模式下(gdb) b subst.c:841 //在subst.c的841行添加断点，也就是string_extract_double_quoted()函数所在的位置Breakpoint 1 at 0x453f91: file subst.c, line 841. (gdb) r task/a.sh //运行a.shStarting program: /home/lijingdong/task/bash-4.4/bash task/a.shBreakpoint 1, string_extract_double_quoted ( string=0x720b08 \"javaOption=\\\"-Da=b -Dc=d\\\"\", sindex=0x7fffffffdf7c, flags=&lt;value optimized out&gt;) at subst.c:841841 string_extract_double_quoted (string, sindex, flags)Missing separate debuginfos, use: debuginfo-install glibc-2.12-1.166.el6_7.7.x86_64(gdb) bt#0 string_extract_double_quoted ( string=0x720b08 \"javaOption=\\\"-Da=b -Dc=d\\\"\", sindex=0x7fffffffdf7c, flags=&lt;value optimized out&gt;) at subst.c:841 //在这里我们就可以看到函数的调用次序了，是 //expand_word_internal函数直接调用了str //ing_extract_double_quoted函数来进行双 //引号处理#1 0x000000000045983f in expand_word_internal (word=0x720ae8, quoted=0, isexp=0, contains_dollar_at=0x7fffffffe088, expanded_something=0x7fffffffe08c) at subst.c:9443#2 0x000000000045b29a in shell_expand_word_list (list=&lt;value optimized out&gt;, eflags=31) at subst.c:10569#3 expand_word_list_internal (list=&lt;value optimized out&gt;, eflags=31) at subst.c:10692 接下来我们只要用grep命令找到expand_word_internal函数进行具体分析即可： 在subst.c中添加的log信息如下： 对于./c.sh $OPTS的执行过程中打印：[DEBUG] word: ./c.sh[DEBUG] word: $OPTS[DEBUG]\\$ begin substitute //在这里执行\\$OPTS的参数扩展[DEBUG]\\$ end substitute之后直接跳出switch循环了。 而对于./c.sh –conf javaOption=”-Da=b -Dc=d”的执行过程中打印：[DEBUG] word: ./task/c.sh[DEBUG] word: –conf[DEBUG] word: javaOption=”-Da=b -Dc=d”[DEBUG]double_quote processing //处理双引号[DEBUG] word: -Da=b -Dc=dDetaching after fork from child process 14855.0:{–conf}1:{javaOption=-Da=b -Dc=d}&#8194;&#8194;&#8194;&#8194;在接下来的switch里边会处理到双引号，调用string_extract_double_quoted()函数将引号内字符串处理为一个整体。&#8194;&#8194;&#8194;&#8194;写到这里也就差不多结束啦，bash源码的解读还有很多需要研究的地方，目前我还只是因为eval命令的原因研究了bash中关于双引号的处理，以此来作为一个引子，也给各位跟我一样的新手提供一个编译调试，解读源码的完整思路，如果大家有什么问题或者文中有什么错误，还请多多指正，多多交流~","updated":"2018-01-21T15:17:24.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"centos+shadowsocks科学上网","date":"2017-02-27T16:00:00.000Z","path":"2017/02/28/centos+shadowsocks科学上网/","text":"像centos这类衍生出来的发行版，他们的源有时候内容更新的比较滞后，或者说有时候一些扩展的源根本就没有。所以在使用yum来search python-pip的时候，会说没有找到该软件包。因此为了能够安装这些包，需要先安装扩展源EPEL 首先安装epel扩展源：1$ sudo yum -y install epel-release 然后安装python版本的pip：1$ sudo yum -y install python-pip 安装shadowsocks：1$ pip install shadowsocks 在/etc目录下创建shadowsocks.json配置文件:1$ vi /etc/shadowsocks.json 输入以下内容：12345678910&#123; &quot;server&quot;:&quot;你的服务器IP，是VPS的哦&quot;, &quot;port_password&quot;:&#123; &quot;8381&quot;:&quot;随意设定8381端口使用密码&quot;, &quot;8382&quot;:&quot;随意设定8382端口使用密码&quot;, &quot;8383&quot;:&quot;随意设定8383端口使用密码&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;此处为加密方式 &#125; 以上设置了三个用户，每个端口对应一个用户 之后启动shadowsocks1$ ssserver -c /etc/shadowsocks.json -d start 可以使用netstat -lnp查看对应端口有没有开始监听，如图服务器端就结束了，之后在客户端安装shadowsocks配置好服务器即可。","updated":"2018-01-21T15:17:01.000Z","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"http://yoursite.com/tags/shadowsocks/"}]}]